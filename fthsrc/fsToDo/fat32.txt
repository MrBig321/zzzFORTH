( USBFAT32)
: USBFS ;   ( marker for FORGET)

HEX 

( : KEY? KEYW DISCARD DROP ; )

04F0000 CONSTANT USBFSPATHBUFF 
04F2000 CONSTANT USBFSLFNNAMEBUFF 
04F3000 CONSTANT USBFSSECTBUFF 
04F4000 CONSTANT USBFSCLUSBUFF 

011 CONSTANT USBFSMAXNAMELEN 

( Dir-Entry)
0   CONSTANT USBFSDENAME      ( 17 bytes, 1st byte is length)
011 CONSTANT USBFSDEATTRIB    ( 1 byte)
012 CONSTANT USBFSDEDATECR    ( 2 bytes	[Year(7), Mon(4), Day(5)])
014 CONSTANT USBFSDEDATELAST  ( 2 bytes	[Year(7), Mon(4), Day(5)])
016 CONSTANT USBFSDEDATEWR    ( 2 bytes	[Year(7), Mon(4), Day(5)])
018 CONSTANT USBFSDECLUSNUM   ( 4 bytes	[first cluster number])
01C CONSTANT USBFSDESIZE      ( 4 bytes)

7 CONSTANT USBFSMAXDIRDEPTH 

02F CONSTANT USBFSROOTDIRCHAR 
02F CONSTANT USBFSPATHSEPACHAR 
02F CONSTANT USBFSDATESEPACHAR 

VARIABLE USBFSPARTLBABEG
VARIABLE USBFSPARTSECTCNT

VARIABLE USBFSBYTESPERSECT
VARIABLE USBFSSECTPERCLUS
VARIABLE USBFSRESSECTCNT
VARIABLE USBFSFATCNT

VARIABLE USBFSSECTPERFAT
VARIABLE USBFSROOTDIRCLUS
VARIABLE USBFSFSINFOSECT
( VARIABLE USBFSBOOTSECTCP)

VARIABLE USBFSMAXCLUSCNTPERWORD
VARIABLE USBFSFATBEGLBA
VARIABLE USBFSCLUSBEGLBA
VARIABLE USBFSROOTDIRLBA

VARIABLE USBFSDIRENTRIESPERCLUS

VARIABLE USBFSNAMEENTRIESCNT
VARIABLE USBFSINITED

CREATE USBFSDIRCLUSTERS USBFSMAXDIRDEPTH CELLS ALLOT 
VARIABLE USBFSDIRCNT
CREATE USBFSSFNBUFF 0D ALLOT 
VARIABLE USBFSCURRSECTNUM

VARIABLE USBFSFREECLUSCNT
VARIABLE USBFSNFREECLUSNUM

: USBFSCHKPARTTYPE  ( -- flag )
   USBFSSECTBUFF 01BE + 4 + C@ DUP 0<> 
   IF DUP 0B = SWAP 0C = OR 
   ELSE DROP TRUE 
   THEN ;

: USBFSCLUS2LBA  ( clusNum -- lba )
   2- USBFSSECTPERCLUS @ * USBFSCLUSBEGLBA @ + ;

: USBFSREADFSINFO  ( -- flag )
   USBFSPARTLBABEG @ USBFSFSINFOSECT @ + DUP 0 USBFSSECTBUFF 1 USBREAD INVERT 
   IF DROP FALSE CR ." Disk read error. " EXIT THEN  
   USBFSCURRSECTNUM ! 
   USBFSSECTBUFF @ 041615252 <> IF FALSE EXIT THEN 
   USBFSSECTBUFF 01E4 + @ 061417272 <> IF FALSE EXIT THEN 
   USBFSSECTBUFF 01FC + @ 0AA550000 <> IF FALSE EXIT THEN 
   USBFSSECTBUFF 01E8 + @ USBFSFREECLUSCNT ! 
   USBFSSECTBUFF 01EC + @ DUP FFFFFFFF = 
   IF USBFSNFREECLUSNUM ! TRUE 
   ELSE DUP USBFSSECTPERFAT @ 7 LSHIFT U>= IF DROP FALSE ELSE USBFSNFREECLUSNUM ! TRUE THEN 
   THEN ;

: USBFSINITSUB  ( -- flag )
   FALSE USBFSINITED ! 0 USBFSDIRCNT ! -1 USBFSCURRSECTNUM !
   FFFFFFFF USBFSFREECLUSCNT ! FFFFFFFF USBFSNFREECLUSNUM !
   0 0 USBFSSECTBUFF 1 USBREAD INVERT 
   IF FALSE CR ." Disk read error. " EXIT THEN
   USBFSCHKPARTTYPE INVERT IF FALSE CR ." Partition-type is not FAT32. " THEN 
   USBFSSECTBUFF 01BE + 8 + DUP @ USBFSPARTLBABEG ! 
   4 + @ USBFSPARTSECTCNT ! 
   USBFSPARTLBABEG @ 0<> 
   IF 
     USBFSPARTLBABEG @ 0 USBFSSECTBUFF 1 USBREAD INVERT 
     IF FALSE CR ." Disk read error. " EXIT THEN
   THEN 
   USBFSSECTBUFF 0B + W@ USBFSBYTESPERSECT ! 
   USBFSSECTBUFF 0D + C@ USBFSSECTPERCLUS ! 
   USBFSSECTBUFF 0E + W@ USBFSRESSECTCNT ! 
   USBFSSECTBUFF 10 + C@ USBFSFATCNT ! 
   USBFSSECTBUFF 024 + @ USBFSSECTPERFAT ! 
   USBFSSECTBUFF 02C + @ USBFSROOTDIRCLUS ! 
   USBFSSECTBUFF 030 + W@ USBFSFSINFOSECT ! 
(   USBFSSECTBUFF 032 + W@ USBFSBOOTSECTCP ! )
   0100 USBFSMAXCLUSCNTPERWORD !
   USBFSBYTESPERSECT @ 0200 = 
   USBFSFATCNT @ 2 = 
   USBFSSECTBUFF 01FE + W@ 0AA55 = AND AND INVERT
   IF FALSE CR ." Invalid FAT32. " EXIT THEN 
   USBFSROOTDIRCLUS @ USBFSDIRCLUSTERS ! 
   USBFSROOTDIRCHAR USBFSPATHBUFF C! 0 USBFSPATHBUFF 1+ C! 
   USBFSPARTLBABEG @ USBFSRESSECTCNT @ + DUP USBFSFATBEGLBA ! 
   USBFSFATCNT @ USBFSSECTPERFAT @ * + USBFSCLUSBEGLBA !
   USBFSROOTDIRCLUS @ USBFSCLUS2LBA USBFSROOTDIRLBA !
   USBFSSECTPERCLUS @ 4 LSHIFT USBFSDIRENTRIESPERCLUS ! 
   USBFSREADFSINFO IF TRUE USBFSINITED ! ELSE CR ." Read FSInfo error. " THEN 
   USBFSINITED @ ;

: USBFSREADFAT  ( lba -- flag )
   DUP USBFSCURRSECTNUM @ = IF DROP TRUE EXIT THEN 
   DUP USBFSFATBEGLBA @ + 0 USBFSSECTBUFF 1 USBREAD 
   IF USBFSCURRSECTNUM ! TRUE 
   ELSE DROP FALSE CR ." FAT read error. " 
   THEN ; 

: USBFSREADCLUS  ( lba -- flag )
   0 USBFSCLUSBUFF USBFSSECTPERCLUS @ USBREAD ;

: USBFSREADCURRDIR  ( -- clusnum flag )
   USBFSDIRCNT @ DUP 0= 
   IF DROP USBFSROOTDIRCLUS @ USBFSROOTDIRLBA @ 
   ELSE CELLS USBFSDIRCLUSTERS + @ DUP USBFSCLUS2LBA 
   THEN USBFSREADCLUS ;

( prints no space after number, unlike dot )
: USBFSPRNSP  ( n -- )
   S>D <# #S #> TYPE ;

: USBFSPRDATE  ( addr offs -- )
   2DUP + W@ 9 RSHIFT 07BC + USBFSPRNSP USBFSDATESEPACHAR EMIT 
   2DUP + W@ 01E0 AND 5 RSHIFT USBFSPRNSP USBFSDATESEPACHAR EMIT 
   + W@ 01F AND U. ;

: USBFSGNCLUSNUM  ( clusNum -- nextClusNum TRUE ) ( clusNum -- FALSE )
   CLRTICKS DUP 7 RSHIFT USBFSREADFAT  
   IF 07F AND 2 LSHIFT USBFSSECTBUFF + @ TRUE
   ELSE DROP FALSE 
   THEN ; 

: USBFSINCENTRY  ( clusNum addrEntry -- clusNum addrNEntry TRUE ) ( clusNum addrEntry -- FALSE )
     020 + DUP USBFSCLUSBUFF - 5 RSHIFT USBFSDIRENTRIESPERCLUS @ U<
     IF TRUE 
     ELSE 
       DROP USBFSGNCLUSNUM 
  ( nextClusNum TRUE )  ( FALSE )
       IF  
         DUP FFFFFFFF = IF 0 TRUE EXIT THEN 
         DUP USBFSCLUS2LBA USBFSREADCLUS 
         IF USBFSCLUSBUFF TRUE  
         ELSE DROP FALSE CR ." Read cluster error. " 
         THEN 
       ELSE FALSE CR ." Get next cluster number error. " 
       THEN 
     THEN ;

: USBFSTOUPPER  ( c -- C )
   DUP 061 U>= OVER 07A U<= AND IF 020 - THEN ;

: USBFSCHKNAME  ( caddr1 caddr2 -- flag )
( !!Here we check the equality of the length as if it was a char!!)
   DUP C@ 1+
   0 DO 
     2DUP C@ USBFSTOUPPER SWAP C@ USBFSTOUPPER <> 
     IF 2DROP FALSE UNLOOP EXIT THEN 1+ SWAP 1+ SWAP 
   LOOP 2DROP TRUE ;

: USBFSGCONSECCLUSCNT  ( clusNum -- nextClusNum cnt TRUE )  ( clusNum -- FALSE )
   DUP 0 >R 
   BEGIN 
     USBFSGNCLUSNUM INVERT IF R> 2DROP FALSE EXIT THEN 
     R> 1+ >R 
    ( clusNum nextClusNum )   ( R: cnt )
     DUP FFFFFFFF = IF NIP R> TRUE EXIT THEN 
     R@ USBFSMAXCLUSCNTPERWORD @ = IF NIP R> TRUE EXIT THEN 
    ( clusNum nextClusNum )   ( R: cnt )
     OVER R@ + OVER <> IF NIP R> TRUE EXIT THEN 
   AGAIN ;

: USBFSRDFL  ( memaddr clusNum -- flag )
   BEGIN 
     DUP USBFSGCONSECCLUSCNT INVERT 
     IF 2DROP FALSE CR ." Get count of consecutive clusters error. " EXIT THEN 
    ( memaddr fileclusnum clusNext cnt )
	 2>R USBFSCLUS2LBA OVER 0 SWAP R> USBFSSECTPERCLUS @ * DUP >R 
    ( memaddr labLo 0 memaddr sectcnt )  ( R: clusNext sectcnt )
     USBREAD INVERT 2R> ROT 
     IF DROP 2DROP FALSE CR ." Disk read error. " EXIT THEN
    ( memaddr clusNext sectcnt )
     USBFSBYTESPERSECT @ * ROT + SWAP 
     CLRTICKS 
    ( memaddr+ clusNext )
     DUP FFFFFFFF =  
   UNTIL 2DROP TRUE ;

( *** Public words ***)

: USBFSINIT  ( devaddr -- lbalo lbahi sectsize flag )
   DUP 0 USBDEVINFO 
   IF USBINITMSD IF USBFSINITSUB ELSE FALSE THEN
   ELSE DROP FALSE 
   THEN ;

: USBFSINFO  ( -- flag )
   USBFSINITED @ 
   IF 
     CR ." FSInfo:" 
     CR ." FAT begin LBA: " USBFSFATBEGLBA ? 
     CR ." Sectors per FAT: " USBFSSECTPERFAT ?
     CR ." Clusters begin LBA: " USBFSCLUSBEGLBA ? 
     CR ." Sectors per cluster: " USBFSSECTPERCLUS ? 
     CR ." Free clusters count: " USBFSFREECLUSCNT ? 
     CR ." Most recently allocated clusternum: " USBFSNFREECLUSNUM ? 
     CR TRUE 
   ELSE FALSE CR ." FS not inited error. " 
   THEN ; 

: USBFSLS  ( flagLongList -- flag )
   USBFSINITED @ INVERT 
   IF DROP FALSE CR ." FS not inited error. " EXIT THEN 
   -1 USBFSCURRSECTNUM ! USBFSREADCURRDIR INVERT 
   IF 2DROP FALSE CR ." Read current directory error. " EXIT THEN 
  ( flagLongList clusnum )
   CR USBFSCLUSBUFF 
  ( flagLongList clusnum addrEntry )
   BEGIN
     DUP C@ 0= IF DROP 2DROP TRUE EXIT THEN 
     DUP C@ 0E5 <> 
     IF 
     ( flagLongList clusnum addrEntry )
       DUP COUNT TYPE SPACE 
       2 PICK 
       IF 
         DUP USBFSDEATTRIB + C@ 010 AND 0<> IF ." d " THEN 
         DUP USBFSDEDATECR USBFSPRDATE DUP USBFSDEDATELAST USBFSPRDATE 
         DUP USBFSDEDATEWR USBFSPRDATE DUP USBFSDESIZE + ? CR 
       THEN 
     THEN 
    ( flagLongList clusNum addrEntry )
     USBFSINCENTRY 
     IF 
       DUP 0= IF DROP 2DROP TRUE EXIT THEN 
     ELSE DROP FALSE EXIT 
     THEN 
   AGAIN ;

: USBFSCD  ( delimcharsdelim  -- flag )
   022 WORD 
   USBFSINITED @ INVERT 
   IF DROP FALSE CR ." FS not inited error. " EXIT THEN 
   DUP C@ USBFSMAXNAMELEN U>= 
   IF DROP FALSE CR ." Name too long error. " EXIT THEN 
   -1 USBFSCURRSECTNUM !
   USBFSDIRCNT @ USBFSMAXDIRDEPTH U>= IF DROP FALSE EXIT THEN 
  ( caddr )
   DUP C@ 1 = 
   IF 
     DUP 1+ C@ 02E = IF DROP TRUE EXIT THEN 
     DUP 1+ C@ USBFSROOTDIRCHAR = IF DROP 0 USBFSDIRCNT ! TRUE EXIT THEN 
   THEN 
   DUP C@ 2 = 
   IF 
     DUP 1+ C@ 02E = OVER 2+ C@ 02E = AND 
     IF 
       USBFSDIRCNT @ 0= 
       IF DROP FALSE EXIT 
       ELSE -1 USBFSDIRCNT +! DROP TRUE EXIT 
       THEN 
     THEN 
   THEN
  ( caddr )
   USBFSREADCURRDIR INVERT 
   IF 2DROP FALSE CR ." Read current directory error. " EXIT THEN 
  ( caddr clusnum )
   USBFSCLUSBUFF 
  ( caddr clusnum addrEntry )
   BEGIN
     DUP C@ 0= IF DROP 2DROP FALSE EXIT THEN 
     DUP C@ 0E5 <> 
     IF 
       OVER USBFSDEATTRIB + C@ 010 AND 0<>   ( directory?)
       IF 
         2 PICK OVER USBFSCHKNAME 
       ( caddr clusnum addrEntry flag )
         IF ( copy name)
       ( caddr clusnum addrEntry )
           ROT USBFSDIRCNT @ 1+ USBFSMAXNAMELEN * USBFSPATHBUFF + USBFSMAXNAMELEN CMOVE 
           DUP USBFSDECLUSNUM + @ 1 USBFSDIRCNT +! USBFSDIRCNT @ 2 LSHIFT USBFSDIRCLUSTERS + ! 
         THEN
       THEN
     THEN 
    ( caddr clusNum addrEntry )
     USBFSINCENTRY 
     IF 
       DUP 0= IF DROP 2DROP TRUE EXIT THEN 
     ELSE DROP FALSE EXIT 
     THEN 
   AGAIN ;

: USBFSPWD  ( -- flag )
   USBFSINITED @ INVERT 
   IF FALSE CR ." FS not inited error. " EXIT THEN 
   CR USBFSPATHBUFF USBFSDIRCNT @ 1+ 0 
   DO DUP COUNT TYPE I 0<> IF USBFSPATHSEPACHAR EMIT THEN USBFSMAXNAMELEN + 
   LOOP DROP TRUE CR ; 

: USBFSREAD  ( memaddr delimcharsdelim -- len flag ) 
   022 WORD 
   USBFSINITED @ INVERT 
   IF 2DROP FALSE CR ." FS not inited error. " EXIT THEN 
   DUP C@ USBFSMAXNAMELEN U>= 
   IF 2DROP FALSE CR ." Name too long error. " EXIT THEN 
   -1 USBFSCURRSECTNUM !
  ( memaddr caddr )
   USBFSREADCURRDIR INVERT 
   IF 2DROP FALSE CR ." Read current directory error. " EXIT THEN 
  ( memaddr caddr dirclusnum )
   USBFSCLUSBUFF 
  ( memaddr caddr dirclusnum addrEntry )
   BEGIN
     DUP C@ 0= IF DROP 2DROP FALSE EXIT THEN 
     DUP C@ 0E5 <> 
     IF 
       DUP USBFSDEATTRIB + C@ AND 010 =  ( not dir?)
     ( memaddr caddr dirclusnum addrEntry flag )
       IF 
         3 PICK OVER USBFSCHKNAME 
         IF 
           >R 2DROP R>
          ( memaddr addrEntry )
           DUP USBFSDESIZE + @ SWAP USBFSDECLUSNUM + @ 
          ( memaddr filesize clusnum )
           >R SWAP R>    ( filesize memaddr clusnum )
           USBFSRDFL     ( filesize flag ) 
           IF TRUE 
           ELSE DROP 0 FALSE 
           THEN EXIT
         THEN 
       THEN 
     THEN 
    ( memaddr caddr clusNum addrEntry )
     USBFSINCENTRY 
     IF 
       DUP 0= IF 2DROP 2DROP TRUE EXIT THEN 
     ELSE 2DROP FALSE EXIT 
     THEN 
   AGAIN ;

: USBFSISNAMEAVAIL  ( caddr clusnum -- flag )
   USBFSCLUSBUFF
   BEGIN 
  ( caddr clusnum addrEntry )
     DUP C@ 0= IF DROP 2DROP TRUE EXIT THEN 
     DUP 3 PICK USBFSCHKNAME IF DROP 2DROP FALSE EXIT THEN 
     USBFSINCENTRY 
     IF 
       DUP 0= IF DROP 2DROP TRUE EXIT THEN 
     ELSE DROP FALSE EXIT 
     THEN 
   AGAIN ;

: USBFSWRITE  ( memaddr sizeinbytes delimcharsdelim -- flag ) 
   022 WORD 
   USBFSINITED @ INVERT 
   IF 2DROP FALSE CR ." FS not inited error. " EXIT THEN 
   DUP C@ USBFSMAXNAMELEN U>= 
   IF 2DROP FALSE CR ." Name too long error. " EXIT THEN 
   -1 USBFSCURRSECTNUM !
( calculate #cluster we need)
  ( memaddr sizeinbytes caddr ) 
   OVER 0<> 
   IF OVER USBFSSECTPERCLUS @ 9 LSHIFT /MOD SWAP 0<> IF 1+ THEN ELSE 0 THEN 
  ( memaddr sizeinbytes caddr cluscnt ) 
   USBFSFREECLUSCNT @ FFFFFFFF = 
   IF 2DROP 2DROP FALSE CR ." Free clusters-count unknown, error!" EXIT THEN 
   DUP USBFSFREECLUSCNT @ U<= 
   IF 2DROP 2DROP FALSE CR ." No free cluster error!" EXIT THEN 
  ( memaddr sizeinbytes caddr cluscnt ) 
   USBFSREADCURRDIR INVERT 
   IF 2DROP 2DROP FALSE CR ." Read current directory error. " EXIT THEN 
  ( memaddr sizeinbytes caddr cluscnt dirclusnum ) 
   2 PICK OVER USBFSISNAMEAVAIL INVERT 
   IF DROP 2DROP 2DROP FALSE CR ." Name already exists error! " EXIT THEN 
xxxxxxxxxxxxx

  ( memaddr caddr dirclusnum )
   USBFSCLUSBUFF 
  ( memaddr caddr dirclusnum addrEntry )
   BEGIN
     DUP C@ 0= IF DROP 2DROP FALSE EXIT THEN 
     DUP C@ 0E5 <> 
     IF 
       DUP USBFSDEATTRIB + C@ AND 010 =  ( not dir?)
     ( memaddr caddr dirclusnum addrEntry flag )
       IF 
         DUP C@ 3 PICK C@ = 
         IF 
           DUP 1+ 3 PICK 1+ DUP 1- C@ USBFSCMPNAME 
           IF 
             >R 2DROP R>
            ( memaddr addrEntry )
             DUP USBFSDESIZE + @ SWAP USBFSDECLUSNUM + @ 
            ( memaddr filesize clusnum )
             >R SWAP R>    ( filesize memaddr clusnum )
             USBFSRDFL     ( filesize flag ) 
             IF TRUE 
             ELSE DROP 0 FALSE 
             THEN EXIT
           THEN 
         THEN 
       THEN 
     THEN 
    ( memaddr caddr clusNum addrEntry )
     USBFSINCENTRY 
     IF 
       DUP 0= IF 2DROP 2DROP TRUE EXIT THEN 
     ELSE 2DROP FALSE EXIT 
     THEN 
   AGAIN ;




