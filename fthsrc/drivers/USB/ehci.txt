( EHCI)
: USB ;   ( marker for FORGET)

( *** For debugging ***)
( : KEY? KEYW DISCARD DROP ; )

HEX

: 3DUP  ( a b c -- a b c a b c )  DUP 2OVER ROT ;
: 3DROP DROP 2DROP ;

( prints no space after number, unlike dot )
: USBPRNSP  ( n -- )
   S>D <# #S #> TYPE ;

: DIGS2  ( b -- )
   DUP 4 RSHIFT 0= IF 030 EMIT THEN USBPRNSP ; 

0500 CONSTANT DEVDESCBUFF  ( from FORTH Memory map !?)

09000 CONSTANT USBBUFF  ( from FORTH Memory map !?)

: USBPRDEVDESC   ( -- )   ( or with DUMP !?)
   CR ." DevDesc:" CR 
   DEVDESCBUFF 012 0 DO DUP C@ DIGS2 SPACE 1+ LOOP DROP CR ;

DEVDESCBUFF 020 + CONSTANT REQDEVDESCPACKET
REQDEVDESCPACKET 8 ERASE
080 REQDEVDESCPACKET C!
6 REQDEVDESCPACKET 1 + C!
0100 REQDEVDESCPACKET 2 + W!

REQDEVDESCPACKET 010 + CONSTANT REQADDRPACKET
REQADDRPACKET 8 ERASE
5 REQADDRPACKET 1 + C!

REQADDRPACKET 010 + CONSTANT REQSTRLANGSPACKET
REQSTRLANGSPACKET 8 ERASE
080  REQSTRLANGSPACKET C!
06   REQSTRLANGSPACKET 1 + C!
0300 REQSTRLANGSPACKET 2 + W!

REQSTRLANGSPACKET 010 + CONSTANT REQCONFIGPACKET
REQCONFIGPACKET 8 ERASE
080  REQCONFIGPACKET C!
06   REQCONFIGPACKET 1 + C!
0200 REQCONFIGPACKET 2 + W!

REQCONFIGPACKET 010 + CONSTANT REQLUNPACKET
REQLUNPACKET 8 ERASE
0A1  REQLUNPACKET C!
0FE  REQLUNPACKET 1 + C!
01   REQLUNPACKET 6 + W!

REQLUNPACKET 010 + CONSTANT REQSCONFIGPACKET
REQSCONFIGPACKET 8 ERASE
09 REQSCONFIGPACKET 1 + C!
01 REQSCONFIGPACKET 2 + W!

REQSCONFIGPACKET 010 + CONSTANT REQBULKRESETPACKET
REQBULKRESETPACKET 8 ERASE
021 REQBULKRESETPACKET C!
0FF REQBULKRESETPACKET 1 + C!

REQBULKRESETPACKET 010 + CONSTANT REQBULKENDPTRESETPACKET
REQBULKENDPTRESETPACKET 8 ERASE
02 REQBULKENDPTRESETPACKET C!
01 REQBULKENDPTRESETPACKET 1 + C!

REQBULKENDPTRESETPACKET 010 + CONSTANT SCSITESTUNITCBW
SCSITESTUNITCBW 01F ERASE
043425355 SCSITESTUNITCBW ! 
0AABBCCDD SCSITESTUNITCBW CELL+ ! 
6 SCSITESTUNITCBW 0E + C! 

SCSITESTUNITCBW 020 + CONSTANT SCSISENSECBW
SCSISENSECBW 01F ERASE
043425355 SCSISENSECBW ! 
0BBAADDCC SCSISENSECBW CELL+ ! 
012 SCSISENSECBW 2 CELLS + ! 
080 SCSISENSECBW 3 CELLS + C! 
 06 SCSISENSECBW 0E + C! 
 03 SCSISENSECBW 0F + C! 
012 SCSISENSECBW 013 + C! 

SCSISENSECBW 020 + CONSTANT SCSIINQUIRYCBW
SCSIINQUIRYCBW 01F ERASE
043425355 SCSIINQUIRYCBW ! 
0AAFFBBFF SCSIINQUIRYCBW CELL+ ! 
024 SCSIINQUIRYCBW 2 CELLS + ! 
080 SCSIINQUIRYCBW 3 CELLS + C! 
 06 SCSIINQUIRYCBW 0E + C! 
012 SCSIINQUIRYCBW 0F + C! 
024 SCSIINQUIRYCBW 013 + C! 

SCSIINQUIRYCBW 020 + CONSTANT SCSIREADCAPACITY10CBW
SCSIREADCAPACITY10CBW 01F ERASE
043425355 SCSIREADCAPACITY10CBW ! 
0CCFFDDFF SCSIREADCAPACITY10CBW CELL+ ! 
 08 SCSIREADCAPACITY10CBW 2 CELLS + ! 
080 SCSIREADCAPACITY10CBW 3 CELLS + C! 
 0A SCSIREADCAPACITY10CBW 0E + C! 
025 SCSIREADCAPACITY10CBW 0F + C! 

SCSIREADCAPACITY10CBW 020 + CONSTANT SCSIREADCAPACITY16CBW
SCSIREADCAPACITY16CBW 01F ERASE
043425355 SCSIREADCAPACITY16CBW ! 
0EEAADDBB SCSIREADCAPACITY16CBW CELL+ ! 
020 SCSIREADCAPACITY16CBW 2 CELLS + ! 
080 SCSIREADCAPACITY16CBW 3 CELLS + C! 
010 SCSIREADCAPACITY16CBW 0E + C! 
09E SCSIREADCAPACITY16CBW 0F + C! 
010 SCSIREADCAPACITY16CBW 010 + C! 

SCSIREADCAPACITY16CBW 020 + CONSTANT SCSIREAD10CBW
SCSIREAD10CBW 01F ERASE
043425355 SCSIREAD10CBW ! 
0DD88EE77 SCSIREAD10CBW CELL+ ! 
080 SCSIREAD10CBW 3 CELLS + C! 
 0A SCSIREAD10CBW 0E + C! 
028 SCSIREAD10CBW 0F + C! 

SCSIREAD10CBW 020 + CONSTANT SCSIREAD12CBW
SCSIREAD12CBW 01F ERASE
043425355 SCSIREAD12CBW ! 
0BBAA7733 SCSIREAD12CBW CELL+ ! 
080 SCSIREAD12CBW 3 CELLS + C! 
 0C SCSIREAD12CBW 0E + C! 
0A8 SCSIREAD12CBW 0F + C! 

SCSIREAD12CBW 020 + CONSTANT SCSIREAD16CBW
SCSIREAD16CBW 01F ERASE
043425355 SCSIREAD16CBW ! 
0BB2255CC SCSIREAD16CBW CELL+ ! 
080 SCSIREAD16CBW 3 CELLS + C! 
 10 SCSIREAD16CBW 0E + C! 
088 SCSIREAD16CBW 0F + C! 

SCSIREAD16CBW 020 + CONSTANT SCSIWRITE10CBW
SCSIWRITE10CBW 01F ERASE
043425355 SCSIWRITE10CBW ! 
033557799 SCSIWRITE10CBW CELL+ ! 
 0A SCSIWRITE10CBW 0E + C! 
02A SCSIWRITE10CBW 0F + C! 

SCSIWRITE10CBW 020 + CONSTANT SCSIWRITE12CBW
SCSIWRITE12CBW 01F ERASE
043425355 SCSIWRITE12CBW ! 
0BBAA7733 SCSIWRITE12CBW CELL+ ! 
 0C SCSIWRITE12CBW 0E + C! 
0AA SCSIWRITE12CBW 0F + C! 

SCSIWRITE12CBW 020 + CONSTANT SCSIWRITE16CBW
SCSIWRITE16CBW 01F ERASE
043425355 SCSIWRITE16CBW ! 
011223344 SCSIWRITE16CBW CELL+ ! 
010 SCSIWRITE16CBW 0E + C! 
08A SCSIWRITE16CBW 0F + C! 

( from FORTH-Memory-Map[FMM] in forth/forth.asm)
0170000 CONSTANT USBHEAPINIT   
030000 CONSTANT USBHEAPSIZE 
USBHEAPINIT USBHEAPSIZE + CONSTANT USBHEAPLIMIT 

VARIABLE USBCURHEAPPTR 
VARIABLE USBCURHEAPPTRSAVED 
VARIABLE USBINITEDMSD 

VARIABLE USBBASE4BITS 
VARIABLE USBBASE0

VARIABLE USBOPBASEOFFS

: USBEBUSMASTER  ( b d f -- )
   4 6 PCICFGWRW ;

: USBGBASE  ( b d f -- )
   010 PCICFGRDD DUP 
   0F AND USBBASE4BITS ! 
   0F INVERT AND USBBASE0 ! ;

: USBGUP32BITS  ( b d f -- n )
   014 PCICFGRDD ; 

: USBCBASEOFF  ( -- )
   USBBASE0 @ C@ USBOPBASEOFFS ! ;

: USBSTCTRL  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + DUP @ 1 INVERT AND SWAP ! ; 

: USBCHHALTED  ( -- flag )
   FALSE USBBASE0 @ USBOPBASEOFFS @ + 4 + 032 0 
   DO DUP @ 1 0C LSHIFT AND 0<> IF NIP TRUE SWAP LEAVE THEN 1 DELAY LOOP DROP ;

: USBRESCTRL  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + DUP @ 1 1 LSHIFT OR SWAP ! ;

: USBCHRESET  ( -- flag )
   FALSE USBBASE0 @ USBOPBASEOFFS @ + 032 0 
   DO DUP @ 1 1 LSHIFT AND 0= IF NIP TRUE SWAP LEAVE THEN 1 DELAY LOOP DROP ;

VARIABLE USBHCSPARAMS 
VARIABLE USBHCCPARAMS 

: USBSAREGS  ( -- ) 
   USBBASE0 @ 4 + DUP @ USBHCSPARAMS ! 4 + @ USBHCCPARAMS ! ; 

( From the book)
( : USBSTLEGACY ) ( b d f -- flag )
(   USBHCCPARAMS @ 0FF00 AND 8 RSHIFT DUP 040 U< IF DROP 3DROP TRUE UNLOOP EXIT THEN )
(   >R 3DUP 3DUP R@ PCICFGRDD 1 018 LSHIFT OR )
  ( b d f b d f val)  ( R: eecp )
(   R@ SWAP PCICFGWRD 0A 0 )
  ( b d f 0A 0 )    ( R: eecp )
(   DO )
(     3DUP R@ PCICFGRDD 1 010 LSHIFT 1 018 LSHIFT OR AND 1 018 LSHIFT = )
(     IF R> DROP 3DROP TRUE UNLOOP EXIT THEN 1 DELAY )
(   LOOP R> DROP 3DROP FALSE ; )

VARIABLE USBEECPID
VARIABLE USBBIOSOWNEDSEMA
VARIABLE USBOSOWNEDSEMA
VARIABLE USBLEGCTLSTS

: USBSTLEGACY  ( b d f -- flag )
   USBHCCPARAMS @ 8 RSHIFT 0FF AND DUP 040 U< IF DROP 3DROP TRUE EXIT THEN 
  ( b d f eecp )
   >R 0 USBEECPID ! 
  ( b d f )  ( R: eecp )
   DUP 0<> 
   IF 
     BEGIN
       3DUP R@ PCICFGRDB USBEECPID ! 
       USBEECPID @ 1 <>
       IF R> 1+ >R 3DUP R> PCICFGRDB >R THEN 
       R@ 0= USBEECPID @ 1 = OR 
     UNTIL 
   THEN 
  ( b d f )  ( R: eecp )
   USBEECPID @ 1 <> IF R> DROP 3DROP TRUE EXIT THEN 
   R@ 2+ USBBIOSOWNEDSEMA ! 
   R@ 3 + USBOSOWNEDSEMA ! 
   R> 4 + USBLEGCTLSTS ! 
  ( b d f )  
   3DUP USBBIOSOWNEDSEMA @ PCICFGRDB 1 AND 0= 
   IF 3DROP TRUE EXIT THEN 
   3DUP USBOSOWNEDSEMA @ 1 PCICFGWRB 
   0FA 0 
   DO
     3DUP USBBIOSOWNEDSEMA @ PCICFGRDB 1 AND 0= IF LEAVE THEN 0A DELAY  
   LOOP  ( TO!?)
   3DUP USBBIOSOWNEDSEMA @ PCICFGRDB 1 AND 0= 
   IF 
     0FA 0 
     DO
       3DUP USBOSOWNEDSEMA @ PCICFGRDB 1 AND 0<> IF LEAVE THEN 0A DELAY  
     LOOP  ( TO!?)
   THEN 
( Write)  
   USBLEGCTLSTS @ 0 PCICFGWRB TRUE ;

VARIABLE USBPORTCNT 

: USBGPORTCNT  ( -- )
   USBHCSPARAMS @ 0F AND USBPORTCNT ! ;

: USBALHEAP  ( size alignment -- addr )
   DUP 1- USBCURHEAPPTR @ + SWAP 1- INVERT AND USBCURHEAPPTR ! 
   3 + 3 INVERT AND 
   ( sizeRoundedToDW )
   DUP USBCURHEAPPTR @ + 1- USBHEAPLIMIT U>= 
   ABORT" Error in allocating memory within our heap! "
   USBCURHEAPPTR @ OVER ERASE 
   USBCURHEAPPTR @ SWAP USBCURHEAPPTR +! ; 

: USBSAHEAPPTR   ( -- )
   USBCURHEAPPTR @ USBCURHEAPPTRSAVED ! ;

: USBRHEAPPTR   ( -- )
   USBCURHEAPPTRSAVED @ USBCURHEAPPTR ! ;

060 CONSTANT USBQHSIZE
2 CONSTANT USBQHSCNT
VARIABLE USBASYNCBASE 

: USBINITQL  ( -- )
   USBQHSCNT USBQHSIZE * 020 USBALHEAP USBASYNCBASE ! ;

: USBINITSTACKFRAME  ( -- )
   USBASYNCBASE @ USBQHSCNT 0 
   DO 
     DUP USBQHSIZE + 2 OR OVER ! 
     2 0C LSHIFT I 0= IF 1 0F LSHIFT OR THEN OVER 4 + ! 
     1 01E LSHIFT OVER 8 + ! 
     1 OVER 010 + ! 
     1 OVER 014 + ! 
     USBQHSIZE + 
   LOOP 
   USBQHSIZE - USBASYNCBASE @ 2 OR SWAP ! ; 

VARIABLE USBBULKINQH 
VARIABLE USBBULKOUTQH 

: USBALBULKQHS  ( -- )
   USBQHSIZE 020 USBALHEAP USBBULKINQH ! 
   USBQHSIZE 020 USBALHEAP USBBULKOUTQH ! ; 

: USBSRTSCHED  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + 
   USBHCCPARAMS @ 1 AND 0<> IF 0 OVER 010 + ! THEN 
   DUP 014 + DUP @ 0FFF AND SWAP ! 
   DUP 018 + DUP @ 01F AND USBASYNCBASE @ 01F INVERT AND OR SWAP ! 
   DUP 0C + DUP @ 03FFF INVERT AND SWAP ! 
   DUP 8 + DUP @ 03F INVERT AND SWAP ! 
   4 + DUP @ 03F OR SWAP ! ; 

: USBSRTCTRL  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + DUP @ 8 010 LSHIFT 1 OR OR SWAP ! ; 

( Not from the book)
: USBEASYNCLIST  ( -- flag )
   FALSE USBBASE0 @ USBOPBASEOFFS @ + DUP @ 1 5 LSHIFT OR OVER ! 4 + 
  ( FALSE statusReg )
   7 0 DO DUP @ 1 0F LSHIFT AND 0<> IF 2DROP TRUE UNLOOP EXIT THEN 0A DELAY LOOP DROP ; 

: USBSPORTS2EHCI  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + 040 + DUP @ 1 OR SWAP ! ; 

: USBSPORTSPWR  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + 044 + USBPORTCNT @ 0 
   DO DUP @ 1 0C LSHIFT OR OVER ! 4 + LOOP ;

VARIABLE USBCTRLMPS 

: USBHANDSHAKE  ( reg mask res ms -- flag )
   0 DO >R 2DUP SWAP @ AND R> SWAP OVER = 
   IF 3DROP TRUE UNLOOP EXIT THEN 1 DELAY LOOP 3DROP FALSE ; 

: USBCLPORTBITS  ( portStatusReg -- )
   USBHCSPARAMS @ 1 4 LSHIFT AND 0<> IF DUP @ 1 0C LSHIFT OR OVER ! THEN 
   DUP @ 1 2 LSHIFT INVERT AND OVER ! 
   DUP @ 1 5 LSHIFT 1 3 LSHIFT 1 1 LSHIFT OR OR OR SWAP ! ; 

: USBCHDEVHSATTACHED  ( portStatusReg -- flag )
   @ DUP 1 AND 0<> SWAP 3 0A LSHIFT AND 0A RSHIFT 1 <> AND ; 

: USBRESPORT  ( portStatusReg -- )
   USBHCSPARAMS @ 1 4 LSHIFT AND 0<> IF DUP @ 1 0C LSHIFT OR OVER ! THEN 
   DUP @ 1 2 LSHIFT INVERT AND OVER ! 
   DUP @ 1 8 LSHIFT OR OVER ! 032 DELAY 
   DUP @ 1 8 LSHIFT INVERT AND SWAP ! 032 DELAY ;

: USBHANDLEDEVLS  ( portStatusReg -- )
   DUP @ 1 2 LSHIFT INVERT OVER ! 
   USBHCSPARAMS @ 1 4 LSHIFT AND 0<> 
   IF DUP @ 1 0C LSHIFT INVERT AND OVER ! THEN DROP 0A DELAY ;

: USBHANDLEDEVS  ( portStatusReg -- flag )
   DUP @ 1 2 LSHIFT AND 0<>
   IF ( found a high speed device)
     DUP @ 07FF1EE AND SWAP ! TRUE 
   ELSE USBHANDLEDEVLS FALSE 
   THEN ;

: USBRESETPORT  ( port -- flag )
   2 LSHIFT 044 + USBBASE0 @ USBOPBASEOFFS @ + + DUP USBCLPORTBITS 
   DUP USBCHDEVHSATTACHED IF DUP USBRESPORT THEN 
   DUP @ 1 AND 0<>
   IF USBHANDLEDEVS  
   ELSE DROP FALSE 
   THEN ;

: USBCRTD  ( addrBuff status addrAltNextTD addrNextTD addrTD -- )
   SWAP OVER ! 4 +  
  ( addrBuff status addrAltNextTD addrTD+ ) 
   SWAP OVER ! 4 + 
  ( addrBuff status addrTD++ ) 
   SWAP OVER ! 4 + 
  ( addrBuff addrTD+++ ) 
   2DUP ! OVER 0<>
   IF 
     SWAP 01000 + 0FFF INVERT AND SWAP 4 + 2DUP ! 
    ( addrBuff+ addrTD++++ ) 
    3 0 DO 4 + SWAP 01000 + SWAP 2DUP ! LOOP 
   THEN 2DROP ; 

: USBCRQH  ( addrTDs devaddr EndPt mps -- addrQH )
   USBQHSIZE 020 USBALHEAP 1 OVER ! 
( addrTDs devaddr EndPt mps addrQH )
   >R 
( addrTDs devaddr EndPt mps )  ( R: addrQH )
   010 LSHIFT SWAP 8 LSHIFT OR 
   8 01C LSHIFT OR 1 0E LSHIFT OR 2 0C LSHIFT OR OR 
   R@ 4 + ! 
   1 01E LSHIFT R@ 8 + ! 
   R@ 010 + ! R> ;

: USBINSQUEUE  ( addrQH -- )
   USBASYNCBASE @ @ OVER ! 
  ( addrQH )
   2 OR USBASYNCBASE @ ! ;  

: USBREMQUEUE  ( addrQH -- flag )
   @ USBASYNCBASE @ ! 
   USBBASE0 @ USBOPBASEOFFS @ + DUP @ 1 6 LSHIFT OR OVER ! 
   4 + DUP 1 5 LSHIFT 1 5 LSHIFT 064 USBHANDSHAKE 
   IF 1 5 LSHIFT OVER @ OR SWAP ! TRUE 
   ELSE DROP FALSE 
   THEN ; 

: USBHANDLEERR  ( status -- )
   DUP 1 6 LSHIFT AND 0<> IF CR ." Polling: stalled error. " THEN
   DUP 1 5 LSHIFT AND 0<> IF CR ." Polling: data buffer error. " THEN
   DUP 1 4 LSHIFT AND 0<> IF CR ." Polling: babble error. " THEN
   DUP 1 3 LSHIFT AND 0<> IF CR ." Polling: NAK error. " THEN
   DUP 1 2 LSHIFT AND 0<> IF CR ." Polling: time out error. " THEN
   DUP 3 AND 0<> IF CR ." Polling: unknown error: " DUP 07F AND U. THEN
   DROP ;

( Newest from the book)
: USBWAITRESPONSE  ( addrTDs msTO -- flag )
   0 
   DO 
     DUP 8 + @ 1 INVERT AND 
    ( addr status )
     DUP 080 AND 0=
     IF 
      ( addr status )
       DUP 07F AND 0<> 
       IF USBHANDLEERR DROP FALSE UNLOOP EXIT THEN 
       DUP 7FFF0000 AND 010 RSHIFT 0> SWAP 3 8 LSHIFT AND 8 RSHIFT 1 = AND 
      ( addr flag )
       IF 
         DUP 4 + @ 1 AND 0= 
         IF 4 + @ 2R> SWAP DROP 0 SWAP 2>R 
         ELSE DROP TRUE UNLOOP EXIT 
         THEN 
       ELSE 
         DUP @ 1 AND 0= 
         IF @ 2R> SWAP DROP 0 SWAP 2>R 
         ELSE DROP TRUE UNLOOP EXIT 
         THEN 
       THEN 
     ELSE DROP
     THEN 
     1 DELAY 
   LOOP 
   DROP FALSE CR ." USB EHCI polling timed out. " ; 

: USBCLDEVDESC  ( -- )
   DEVDESCBUFF 012 ERASE ; 

VARIABLE USBDEVADDR 
VARIABLE USBASYNCTDS 
VARIABLE USBTDCNT 
VARIABLE USBDATATOGGLE 
VARIABLE USBBULK
VARIABLE USBDATARDY 

: USBSETUPSTAGE  ( addrBuff addrTDs -- addrTDs+ ) 
   >R
   8 010 LSHIFT 3 0A LSHIFT OR 2 8 LSHIFT OR 080 OR 
   1 
   R@ 040 + 
   R@ USBCRTD R> 040 + ; 

VARIABLE USBMPS

: USBDATASTAGE  ( addrBuff dirFlag len addrTDs -- addrTDs+ ) 
     USBBULK @ INVERT IF 1 USBDATATOGGLE ! THEN 2>R 
  ( ioBuffAddr dirFlag )  ( R: len addrTDs+ )
     FALSE USBDATARDY !
   BEGIN 
     DUP >R OVER 
     USBTDCNT @ 1 = IF R> 2R@ DROP SWAP >R ELSE USBMPS @ THEN 010 LSHIFT 
     USBBULK @ INVERT IF USBDATATOGGLE @ 01F LSHIFT OR THEN 
     3 0A LSHIFT OR 080 OR R> IF 1 8 LSHIFT OR THEN 
     USBBULK @ 
     IF
       USBTDCNT @ 1 = 
       IF 1 1 
       ELSE 1 R@ 040 +   
       THEN
       R@ 
     ELSE 
       R@ 040 + DUP  
       R@ 
     THEN
     USBCRTD 
   ( ioBuffAddr dirFlag )  ( R: len addrTDs+ )
     R> 040 + >R 
   ( ioBuffAddr dirFlag )  ( R: len addrTDs+ )
     -1 USBTDCNT +! USBTDCNT @ 0= IF TRUE USBDATARDY ! THEN 
     USBDATARDY @ INVERT 
     IF 
       USBMPS @ 2R> >R SWAP - R> 2>R  
       SWAP USBMPS @ + SWAP 
       USBBULK @ IF USBDATATOGGLE @ 1 XOR USBDATATOGGLE ! THEN 
    ( ioBuffAddr+ dirFlag )  ( R: len addrTDs+ )
     THEN 
     USBDATARDY @
    UNTIL 2DROP 2R> NIP ;

: USBSTATUSSTAGE  ( dirFlag addrTDs -- )
   >R >R
   0 
   1 01F LSHIFT 3 0A LSHIFT OR 080 OR R> INVERT IF 1 8 LSHIFT OR THEN 
   1 
   1 
   R> USBCRTD ; 

: USBCTRLIO  ( ioBuffAddr dirFlag recPacket len -- flag )
   2DUP SWAP 6 + W! 
   DUP >R USBCTRLMPS @ /MOD 
   USBTDCNT ! 0> IF 1 USBTDCNT +! THEN 
  ( ioBuffAddr dirFlag recPacket )  ( R: len )
( alloc TDs)
   USBTDCNT @ 2+ 040 * 020 USBALHEAP DUP USBASYNCTDS ! 
  ( ioBuffAddr dirFlag recPacket addrTDs )  ( R: len )
   >R
  ( ioBuffAddr dirFlag recPacket )  ( R: len addrTDs )
   R> USBSETUPSTAGE >R
  ( ioBuffAddr dirFlag )  ( R: len addrTDs+ )
   USBTDCNT @ 0<>
   IF SWAP OVER 2R> USBCTRLMPS @ USBMPS ! FALSE USBBULK ! USBDATASTAGE 
   ELSE NIP 2R> NIP THEN 
  ( dirFlag addrTDs+ )
   USBSTATUSSTAGE 
  ( empty )
( QH)
   USBASYNCTDS @ USBDEVADDR @ 0 USBCTRLMPS @ USBCRQH 
  ( addrQH )
   DUP USBINSQUEUE 
   USBASYNCTDS @ 07D0 USBWAITRESPONSE 
   SWAP USBREMQUEUE AND ;

: USBPRVENDORSTR  ( buffAddr -- )
   DUP C@ 2- 1 RSHIFT 0 DO 2+ DUP C@ EMIT LOOP DROP ; 

: USBPRPORTDEVADDR  ( port -- )
  ."  (" USBPRNSP 02C EMIT SPACE USBDEVADDR @ USBPRNSP 029 EMIT CR ;

: USBUPDMPS  ( -- )
   DEVDESCBUFF 7 + C@ DUP 64 U<= OVER USBCTRLMPS @ <> AND 
   IF USBCTRLMPS ! ELSE DROP THEN ; 

: USBGDEVDESC  ( -- flag )
   DEVDESCBUFF TRUE REQDEVDESCPACKET 012 USBCTRLIO 
   IF USBUPDMPS TRUE 
   ELSE FALSE CR ." Getting device descriptor failed. " 
   THEN ;

: USBSADDR  ( devaddr -- flag )
   REQADDRPACKET 2 + C! 
   0 FALSE REQADDRPACKET 0 USBCTRLIO DUP 
   INVERT IF CR ." Setting address failed. " THEN ; 

: USBGLANGID  ( -- langId TRUE )  ( -- FALSE )
   0 REQSTRLANGSPACKET 2 + C! 0 REQSTRLANGSPACKET 4 + C! 
   USBBUFF DUP >R TRUE REQSTRLANGSPACKET 012 USBCTRLIO 
   R> SWAP 
   IF 2+ W@ TRUE  
   ELSE DROP FALSE CR ." Getting LangIds failed. " 
   THEN ; 

: USBGMANUF  ( langId -- flag )
   DEVDESCBUFF 0E + C@ DUP 0<>
   IF  ( get ManufStr)
     REQSTRLANGSPACKET 2 + C! REQSTRLANGSPACKET 4 + C! 
     USBBUFF DUP >R TRUE REQSTRLANGSPACKET 040 USBCTRLIO 
     R> SWAP  
     INVERT IF DROP FALSE CR ." Getting ManufStr failed. " EXIT THEN 
    ( ioBuffAddr )  
     USBPRVENDORSTR
   ELSE DROP CR ." None"
   THEN TRUE ;

: USBGPROD  ( langId -- flag )
   DEVDESCBUFF 0F + C@ DUP 0<>
   IF 
     REQSTRLANGSPACKET 2 + C! REQSTRLANGSPACKET 4 + C! 
     USBBUFF DUP >R TRUE REQSTRLANGSPACKET 040 USBCTRLIO 
     R> SWAP  
     INVERT IF DROP FALSE CR ." Getting ProdStr failed. " EXIT THEN 
     USBPRVENDORSTR
   ELSE DROP ." None" CR 
   THEN TRUE ;

: USBGSTRDESC  ( -- flag )
   USBGLANGID INVERT IF FALSE EXIT THEN 
   DUP USBGMANUF INVERT IF FALSE EXIT THEN 
   ." - " USBGPROD ; 

VARIABLE USBDEVADDRTMP 

: USBGDESCRIPTORS   ( port -- flag )
   USBCLDEVDESC USBDEVADDR @ USBDEVADDRTMP ! 0 USBDEVADDR ! 
   USBGDEVDESC INVERT IF DROP FALSE EXIT THEN 
   USBDEVADDRTMP @ USBSADDR 
   INVERT IF DROP FALSE EXIT THEN 
   USBDEVADDRTMP @ USBDEVADDR ! 
   2 DELAY USBGSTRDESC 
   IF USBPRPORTDEVADDR TRUE ELSE DROP FALSE THEN ; 

: USBDETPORTS  ( -- )
   USBPORTCNT @ 0 
   DO I USBRESETPORT IF I 1+ USBDEVADDR ! I USBGDESCRIPTORS DROP THEN LOOP ;

: USBPROCESS  ( b d f -- flag )
   3DUP USBEBUSMASTER 
   3DUP USBGBASE USBBASE4BITS @ 1 AND 0<> 
   IF 3DROP FALSE CR ." USB not memory mapped IO. " EXIT THEN
   USBBASE4BITS @ 4 = 
   IF 3DUP USBGUP32BITS 0<> 
     IF 3DROP FALSE CR ." Base0 is 64-bits (32bit OS). " EXIT THEN 
   THEN
   USBCBASEOFF USBSTCTRL USBCHHALTED INVERT 
   IF 3DROP FALSE CR ." Checking HCHALTED timed out. " EXIT THEN 
   USBRESCTRL USBCHRESET INVERT 
   IF 3DROP FALSE CR ." Resetting the controller failed (TO). " EXIT THEN 
   USBSAREGS USBSTLEGACY INVERT 
   IF FALSE CR ." BIOS did not release legacy support. " EXIT THEN 
   USBGPORTCNT USBINITQL USBINITSTACKFRAME USBALBULKQHS 
   USBSRTSCHED USBSRTCTRL USBEASYNCLIST INVERT 
   IF FALSE CR ." Enabling async-list failed. " EXIT THEN 
   USBSPORTS2EHCI USBHCSPARAMS @ 1 4 LSHIFT AND 0<> 
   IF USBSPORTSPWR THEN 014 DELAY 040 USBCTRLMPS ! USBDETPORTS TRUE ( !?) ; 

VARIABLE USBBUS

: PCIDETUSB  ( -- b d f TRUE )   ( -- FALSE )
   FALSE 0100 0 DO I USBBUS ! 020 0 DO 8 0 DO USBBUS @ J I 0 PCICFGRDW 0FFFF <> 
       IF USBBUS @ J I 0B PCICFGRDB 0C = IF USBBUS @ J I 0A PCICFGRDB 3 = 
       IF USBBUS @ J I 9 PCICFGRDB 020 = IF DROP USBBUS @ J I TRUE THEN THEN THEN THEN 
   LOOP LOOP LOOP ;

VARIABLE USBCSWADDR 
: USBGCLEAREDCSWADDR  ( -- addr )
   USBCSWADDR @ DUP 0D ERASE ;

VARIABLE USBENUMDONE 

: USBENUM  ( -- flag )
   PCIDETUSB 
   IF USBHEAPINIT USBCURHEAPPTR !
      -1 USBDEVADDR ! 0FF USBINITEDMSD !
      0D 1 USBALHEAP USBCSWADDR !
      CR ." Found EHCI controller " >R >R DUP DIGS2 ." :" R> DUP DIGS2 
      ." :" R> DUP DIGS2 CR ." String (Port, DeviceAddress)" CR 
      USBPROCESS DUP USBENUMDONE ! 
   ELSE FALSE
   THEN ;

: USBGCONFIGDESC  ( len -- flag )
   >R USBBUFF TRUE REQCONFIGPACKET R> USBCTRLIO 
   DUP INVERT IF CR ." Getting config descriptor failed. " THEN ;

: USBPRCONFIGDESC   ( -- )   ( or with DUMP !?)
   CR ." ConfigDesc:" CR USBBUFF DUP 2+ W@ 0 DO DUP C@ DIGS2 SPACE 1+ LOOP DROP CR ;

VARIABLE USBBULKINEPT 
VARIABLE USBBULKOUTEPT 

: USBSAENDPTNUM  ( endptByte -- endptnum )
  DUP 080 AND 0<> IF 0F AND DUP USBBULKINEPT ! ELSE 0F AND DUP USBBULKOUTEPT ! THEN ;

VARIABLE USBBULKINMPS 
VARIABLE USBBULKOUTMPS 

: USBSAENDPTMPS  ( endptmps endptnum -- )
  1 = IF USBBULKINMPS ! ELSE USBBULKOUTMPS ! THEN ;

: USBSAENDPTS ( -- flag )
  USBBUFF DUP C@ + DUP 4 + C@ 1 <= 
  IF DROP FALSE CR ." Not enough endpoints" EXIT THEN
  DUP C@ + DUP 2+ C@ USBSAENDPTNUM OVER 4 + W@ SWAP USBSAENDPTMPS 
  DUP C@ + DUP 1+ C@ 030 = IF DUP C@ + THEN 
  DUP 2+ C@ USBSAENDPTNUM SWAP 4 + W@ SWAP USBSAENDPTMPS TRUE ;

: USBMSD?   ( -- flag )
  USBBUFF 4 + C@ 0<> 
  IF USBBUFF DUP C@ + 5 + C@ 8 = ELSE FALSE THEN ;

: USBGLUN  ( -- flag )
   USBBUFF TRUE REQLUNPACKET 1 USBCTRLIO 
   DUP INVERT IF CR ." Getting LUN failed. " THEN ;

VARIABLE USBMAXLUN 

: USBSALUN  ( -- )
  USBBUFF C@ DUP 0FF = IF DROP 0 THEN USBMAXLUN ! ; 

: USBPRLUN  ( -- )
  CR ." MaxLun: " USBMAXLUN ? ;

( idx=0: print nothing)
( idx=1: print device-descriptor only)
( idx=2: print all the descriptors)
( If device is a Mass-Storage one [0x08], then prints MaxLun)
: USBDEVINFO  ( devaddr idx -- flag )
   USBENUMDONE @ INVERT IF 2DROP FALSE CR ." USBENUM needs to be executed first. " EXIT THEN 
   0FF USBINITEDMSD ! SWAP USBDEVADDR !
  ( idx )
   DUP 0<> IF CR ." Getting Device-descriptor ..." THEN 
   USBGDEVDESC INVERT IF DROP FALSE EXIT THEN 
   DUP 0<> IF USBPRDEVDESC THEN 
   DUP 2 = IF CR ." Getting Configuration-descriptor ..." THEN 
   040 USBGCONFIGDESC INVERT IF DROP FALSE EXIT THEN 
   USBBUFF 2+ W@ DUP 040 U>
   IF USBGCONFIGDESC INVERT IF DROP FALSE EXIT THEN ELSE DROP THEN
   DUP 2 = IF USBPRCONFIGDESC THEN 
   USBSAENDPTS INVERT IF DROP FALSE EXIT THEN 
   USBMSD? INVERT IF DROP TRUE EXIT THEN 
   DUP 2 = IF CR ." Getting LUN ..." THEN 
   USBGLUN INVERT IF DROP FALSE EXIT THEN 
   USBSALUN 2 = IF USBPRLUN THEN TRUE ;

: USBBULKRESET  ( -- flag )
   USBBUFF FALSE REQBULKRESETPACKET 0 USBCTRLIO ; 

: USBCLDT  ( -- )
   0 USBBULKINQH @ 018 + ! 0 USBBULKOUTQH @ 018 + ! ;

VARIABLE USBCURRTAG
VARIABLE USBDEVSIZE
VARIABLE USBSCSICAP 
VARIABLE USBSECTORSI
VARIABLE USBMAXLBAHI
VARIABLE USBMAXLBALO 

: USBUPDQH  ( addrTDs devaddr bulkMPS bulkEndPt addrQH -- )
   >R
   1 R@ !
   8 LSHIFT SWAP 010 LSHIFT OR OR 8 01C LSHIFT OR 2 0C LSHIFT OR R@ 4 + !
   1 01E LSHIFT R@ 8 + !
   0 R@ 0C + !
   R@ 010 + !
   1 R> 014 + ! ;

: USBBULKIO ( buffAddr dirFlag len -- flag )
   DUP 05000 /MOD 
   USBTDCNT ! 0> IF 1 USBTDCNT +! THEN 
   USBTDCNT @ 040 * 020 USBALHEAP DUP USBASYNCTDS ! 
  ( buffAddr dirFlag len addrTDs )  
   2OVER NIP >R   ( R: dirFlag )
   05000 USBMPS ! TRUE USBBULK ! USBDATASTAGE DROP 
  ( R: dirFlag )
   USBASYNCTDS @ USBDEVADDR @ R@ 
   IF USBBULKINMPS @ ELSE USBBULKOUTMPS @ THEN R@ 
   IF USBBULKINEPT @ ELSE USBBULKOUTEPT @ THEN R@  
   IF USBBULKINQH @ ELSE USBBULKOUTQH @ THEN 
   USBUPDQH 
  ( R: dirFlag )
   R> IF USBBULKINQH @ ELSE USBBULKOUTQH @ THEN 
  ( addrQH )
   DUP USBINSQUEUE 
   USBASYNCTDS @ 01388 USBWAITRESPONSE 
   SWAP USBREMQUEUE AND ;

: USBCHKCSW  ( buffAddr tag -- flag )
   OVER 4 + @ = 
   IF 0C + C@ 0= 
   ELSE DROP FALSE 
   THEN ;

: USBSCSIREQ  ( buffAddr len -- flag )
   >R DUP 4 + @ USBCURRTAG !
  ( buffAddr )   ( R: len )
   FALSE 01F
  ( buffAddr dirFlag size )  ( R: len )
   USBBULKIO INVERT IF R> DROP FALSE CR ." Send CBW failed. " EXIT THEN 
   R@ 0<>
   IF 
     R@ 
    ( len )   ( R: len )
     1 USBALHEAP DUP TRUE R@
    ( bulkArrAddr bulkArrAddr dir len )  ( R: len )
     USBBULKIO INVERT IF R> 2DROP FALSE CR ." Get CBW failed. " EXIT THEN 
     R> USBSCSICAP @ 
     IF 
       020 <>
       IF 
         DUP @ BSWAP4 USBMAXLBALO ! 0 USBMAXLBAHI ! 
         4 + @ BSWAP4 USBSECTORSI ! 
       ELSE 
         DUP @ BSWAP4 USBMAXLBAHI ! 
         4 + DUP @ BSWAP4 USBMAXLBALO ! 
         4 + @ BSWAP4 USBSECTORSI ! 
       THEN 
     ELSE 2DROP 
     THEN  
   ELSE R> DROP
   THEN
   USBGCLEAREDCSWADDR DUP >R TRUE 0D
  ( bulkArrAddr dir len )  ( R: addrCSW )
   USBBULKIO INVERT IF R> DROP FALSE CR ." Get CSW failed. " EXIT THEN 
   R> USBCURRTAG @ USBCHKCSW DUP
   INVERT IF CR ." Check CSW failed. " THEN ;

: USBINITMSD  ( devaddr -- lbaLo lbaHI sectorSize flag ) 
   USBDEVADDR @ <> IF 0 0 0 FALSE EXIT THEN 
   USBBUFF FALSE REQSCONFIGPACKET 0 USBCTRLIO 
   INVERT IF 0 0 0 FALSE CR ." SetConfig failed" EXIT THEN 
   USBBULKRESET INVERT IF 0 0 0 FALSE CR ." Bulk reset failed. " EXIT THEN 
   064 DELAY USBCLDT 064 DELAY
   FALSE USBSCSICAP !
   SCSIINQUIRYCBW 024 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." InquiryReq failed" EXIT THEN 
   SCSITESTUNITCBW 0 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." TestUnitReq failed" EXIT THEN 
   SCSISENSECBW 012 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." SenseReq failed" EXIT THEN 
   SCSITESTUNITCBW 0 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." TestUnitReq failed" EXIT THEN 
   TRUE USBSCSICAP !
   0 USBDEVSIZE !
   SCSIREADCAPACITY10CBW 8 USBSCSIREQ 
   INVERT IF 0 0 0 FALSE CR ." ReadCapacity failed" EXIT THEN
   USBMAXLBALO @ FFFFFFFF =  
   IF DROP 2DROP SCSIREADCAPACITY16CBW 020 USBSCSIREQ 
     INVERT IF 0 0 0 FALSE CR ." ReadCapacity failed" EXIT THEN
     2 USBDEVSIZE ! 
   ELSE USBMAXLBALO @ 01000000 U> IF 1 USBDEVSIZE ! THEN 
   THEN 
   USBMAXLBALO @ USBMAXLBAHI @ USBSECTORSI @
   USBDEVADDR @ USBINITEDMSD ! TRUE ;

: USBALIGNTOPAGE  ( addr -- addrAligned )
   DUP 0FFF AND 0<> IF FFFFF000 AND 01000 + THEN ;

: USBRDWRCOMMON  ( memAddr byteCntToRead flagRW cbw -- flag )
   >R 2>R USBALIGNTOPAGE 2R> R> DUP 4 + 1 OVER +! @ USBCURRTAG !
   FALSE 01F USBBULKIO INVERT
   IF DROP 2DROP FALSE CR ." Send CBW failed. " EXIT THEN
  ( memAddr byteCntToRead flagRW )
   SWAP USBBULKIO INVERT 
   IF FALSE CR ." Get/Send data failed. " EXIT THEN
   USBGCLEAREDCSWADDR DUP TRUE 0D USBBULKIO INVERT 
   IF DROP FALSE CR ." Get CSW failed. " EXIT THEN
   USBCURRTAG @ USBCHKCSW DUP INVERT 
   IF CR ." Check CSW failed. " THEN ;

: USBRDWR10REQ  ( LBALo memAddr sectorcnt flagRW cbw -- flag )
   2>R ROT BSWAP4 R@ 011 + ! DUP BSWAP2 R@ 016 + W! 
   USBSECTORSI @ * DUP R@ 8 + ! 2R> USBRDWRCOMMON ;

: USBRDWR12REQ  ( LBALo memAddr sectorcnt flagRW cbw -- flag )
   2>R ROT BSWAP4 R@ 011 + ! DUP BSWAP4 R@ 015 + ! 
   USBSECTORSI @ * DUP R@ 8 + ! 2R> USBRDWRCOMMON ;

: USBRDWR16REQ  ( LBALo LBAHi memAddr sectorcnt flagRW cbw -- flag )
   2>R ROT BSWAP4 R@ 011 + ! ROT BSWAP4 R@ 015 + ! 
   DUP BSWAP4 R@ 019 + ! 
   USBSECTORSI @ * DUP R@ 8 + ! 2R> USBRDWRCOMMON ;

: USBRWCHK  ( lbalo lbaHi -- flag )
   USBDEVADDR @ USBINITEDMSD @ <> 
   IF 2DROP FALSE CR ." MSD not inited." 
   ELSE 
     USBMAXLBALO @ USBMAXLBAHI @ DU< 
     IF TRUE ELSE FALSE CR ." LBA too big." THEN
   THEN ;

: USBREAD  ( lbalo lbaHi memAddr sectorcnt -- flag )
   2OVER USBRWCHK 
   IF  
     USBDEVSIZE @ 
     CASE 
       0 OF >R ROT DROP TRUE SCSIREAD10CBW USBRDWR10REQ R> ENDOF 
       1 OF >R ROT DROP TRUE SCSIREAD12CBW USBRDWR12REQ R> ENDOF 
       2 OF >R          TRUE SCSIREAD16CBW USBRDWR16REQ R> ENDOF 
     ENDCASE 
   ELSE 2DROP 2DROP FALSE THEN ;

: USBWRITE  ( lbalo lbaHi memAddr sectorcnt -- flag )
   2OVER USBRWCHK 
   IF  
     USBDEVSIZE @ 
     CASE 
       0 OF >R ROT DROP FALSE SCSIWRITE10CBW USBRDWR10REQ R> ENDOF 
       1 OF >R ROT DROP FALSE SCSIWRITE12CBW USBRDWR12REQ R> ENDOF 
       2 OF >R          FALSE SCSIWRITE16CBW USBRDWR16REQ R> ENDOF 
     ENDCASE 
   ELSE 2DROP 2DROP FALSE THEN ;


