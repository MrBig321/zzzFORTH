( XHCI)
: USB ;   ( marker for FORGET)

( *** For debugging ***)
( : KEY? KEYW DISCARD DROP ; )

HEX

: 3DUP  ( a b c -- a b c a b c )  DUP 2OVER ROT ;
: 3DROP DROP 2DROP ;

( prints no space after number, unlike dot )
: USBPRNSP  ( n -- )
   S>D <# #S #> TYPE ;

: DIGS2  ( b -- )
   DUP 4 RSHIFT 0= IF 030 EMIT THEN USBPRNSP ; 

0500 CONSTANT DEVDESCBUFF  ( from FORTH Memory map !?)

DEVDESCBUFF 020 + CONSTANT REQDEVDESCPACKET
REQDEVDESCPACKET 8 ERASE
080 REQDEVDESCPACKET C!
6 REQDEVDESCPACKET 1 + C!
0100 REQDEVDESCPACKET 2 + W!

REQDEVDESCPACKET 010 + CONSTANT REQSTRLANGSPACKET
REQSTRLANGSPACKET 8 ERASE
080  REQSTRLANGSPACKET C!
06   REQSTRLANGSPACKET 1 + C!
0300 REQSTRLANGSPACKET 2 + W!

REQSTRLANGSPACKET 010 + CONSTANT REQCONFIGPACKET
REQCONFIGPACKET 8 ERASE
080  REQCONFIGPACKET C!
06   REQCONFIGPACKET 1 + C!
0200 REQCONFIGPACKET 2 + W!

REQCONFIGPACKET 010 + CONSTANT REQLUNPACKET
REQLUNPACKET 8 ERASE
0A1  REQLUNPACKET C!
0FE  REQLUNPACKET 1 + C!
01   REQLUNPACKET 6 + W!

REQLUNPACKET 010 + CONSTANT REQSCONFIGPACKET
REQSCONFIGPACKET 8 ERASE
09 REQSCONFIGPACKET 1 + C!
01 REQSCONFIGPACKET 2 + W!

REQSCONFIGPACKET 010 + CONSTANT REQBOSPACKET
REQBOSPACKET 8 ERASE
080 REQBOSPACKET C!
06  REQBOSPACKET 1 + C!
0F00 REQBOSPACKET 2 + W!

REQBOSPACKET 010 + CONSTANT REQBULKRESETPACKET
REQBULKRESETPACKET 8 ERASE
021 REQBULKRESETPACKET C!
0FF REQBULKRESETPACKET 1 + C!

REQBULKRESETPACKET 010 + CONSTANT REQBULKENDPTRESETPACKET
REQBULKENDPTRESETPACKET 8 ERASE
02 REQBULKENDPTRESETPACKET C!
01 REQBULKENDPTRESETPACKET 1 + C!

REQBULKENDPTRESETPACKET 010 + CONSTANT SCSITESTUNITCBW
SCSITESTUNITCBW 01F ERASE
043425355 SCSITESTUNITCBW ! 
0AABBCCDD SCSITESTUNITCBW CELL+ ! 
6 SCSITESTUNITCBW 0E + C! 

SCSITESTUNITCBW 020 + CONSTANT SCSISENSECBW
SCSISENSECBW 01F ERASE
043425355 SCSISENSECBW ! 
0BBAADDCC SCSISENSECBW CELL+ ! 
012 SCSISENSECBW 2 CELLS + ! 
080 SCSISENSECBW 3 CELLS + C! 
 06 SCSISENSECBW 0E + C! 
 03 SCSISENSECBW 0F + C! 
012 SCSISENSECBW 013 + C! 

SCSISENSECBW 020 + CONSTANT SCSIINQUIRYCBW
SCSIINQUIRYCBW 01F ERASE
043425355 SCSIINQUIRYCBW ! 
0AAFFBBFF SCSIINQUIRYCBW CELL+ ! 
024 SCSIINQUIRYCBW 2 CELLS + ! 
080 SCSIINQUIRYCBW 3 CELLS + C! 
 06 SCSIINQUIRYCBW 0E + C! 
012 SCSIINQUIRYCBW 0F + C! 
024 SCSIINQUIRYCBW 013 + C! 

SCSIINQUIRYCBW 020 + CONSTANT SCSIREADCAPACITY10CBW
SCSIREADCAPACITY10CBW 01F ERASE
043425355 SCSIREADCAPACITY10CBW ! 
0CCFFDDFF SCSIREADCAPACITY10CBW CELL+ ! 
 08 SCSIREADCAPACITY10CBW 2 CELLS + ! 
080 SCSIREADCAPACITY10CBW 3 CELLS + C! 
 0A SCSIREADCAPACITY10CBW 0E + C! 
025 SCSIREADCAPACITY10CBW 0F + C! 

SCSIREADCAPACITY10CBW 020 + CONSTANT SCSIREADCAPACITY16CBW
SCSIREADCAPACITY16CBW 01F ERASE
043425355 SCSIREADCAPACITY16CBW ! 
0EEAADDBB SCSIREADCAPACITY16CBW CELL+ ! 
020 SCSIREADCAPACITY16CBW 2 CELLS + ! 
080 SCSIREADCAPACITY16CBW 3 CELLS + C! 
010 SCSIREADCAPACITY16CBW 0E + C! 
09E SCSIREADCAPACITY16CBW 0F + C! 
010 SCSIREADCAPACITY16CBW 010 + C! 

SCSIREADCAPACITY16CBW 020 + CONSTANT SCSIREAD10CBW
SCSIREAD10CBW 01F ERASE
043425355 SCSIREAD10CBW ! 
0DD88EE77 SCSIREAD10CBW CELL+ ! 
080 SCSIREAD10CBW 3 CELLS + C! 
 0A SCSIREAD10CBW 0E + C! 
028 SCSIREAD10CBW 0F + C! 

SCSIREAD10CBW 020 + CONSTANT SCSIREAD12CBW
SCSIREAD12CBW 01F ERASE
043425355 SCSIREAD12CBW ! 
0BBAA7733 SCSIREAD12CBW CELL+ ! 
080 SCSIREAD12CBW 3 CELLS + C! 
 0C SCSIREAD12CBW 0E + C! 
0A8 SCSIREAD12CBW 0F + C! 

SCSIREAD12CBW 020 + CONSTANT SCSIREAD16CBW
SCSIREAD16CBW 01F ERASE
043425355 SCSIREAD16CBW ! 
0BB2255CC SCSIREAD16CBW CELL+ ! 
080 SCSIREAD16CBW 3 CELLS + C! 
 10 SCSIREAD16CBW 0E + C! 
088 SCSIREAD16CBW 0F + C! 

SCSIREAD16CBW 020 + CONSTANT SCSIWRITE10CBW
SCSIWRITE10CBW 01F ERASE
043425355 SCSIWRITE10CBW ! 
033557799 SCSIWRITE10CBW CELL+ ! 
 0A SCSIWRITE10CBW 0E + C! 
02A SCSIWRITE10CBW 0F + C! 

SCSIWRITE10CBW 020 + CONSTANT SCSIWRITE12CBW
SCSIWRITE12CBW 01F ERASE
043425355 SCSIWRITE12CBW ! 
0BBAA7733 SCSIWRITE12CBW CELL+ ! 
 0C SCSIWRITE12CBW 0E + C! 
0AA SCSIWRITE12CBW 0F + C! 

SCSIWRITE12CBW 020 + CONSTANT SCSIWRITE16CBW
SCSIWRITE16CBW 01F ERASE
043425355 SCSIWRITE16CBW ! 
011223344 SCSIWRITE16CBW CELL+ ! 
010 SCSIWRITE16CBW 0E + C! 
08A SCSIWRITE16CBW 0F + C! 

( from FORTH-Memory-Map[FMM] in forth/forth.asm)
0600000 CONSTANT USBHEAPINIT   
0400000 CONSTANT USBHEAPSIZE 
USBHEAPINIT USBHEAPSIZE + CONSTANT USBHEAPLIMIT 

01000 CONSTANT USBMAXTRBCNTPERTRRING 
01E CONSTANT USBMAXSEGMENTCNTPERTRRING 

CREATE USBTRRINGSEGMENTS USBMAXSEGMENTCNTPERTRRING CELLS ALLOT 
CREATE USBTRRINGSEGMENTCNTS USBMAXSEGMENTCNTPERTRRING CELLS ALLOT 

0400 CONSTANT USBCMNDRINGTRBS 
0400 CONSTANT USBTRBSPERRING 
01000 CONSTANT USBTRBSPEREVENTRING	     ( currently only one segment is created in xhci_create_event_ring, so this is the maximum)
01000 01C * CONSTANT USBTRBSPERBULKRING ( we can read at least a 45Mb file with this; see also USBHEAPSIZE)

09000 CONSTANT USBBUFF  ( from FORTH Memory map !?)

1 011 LSHIFT 1 012 LSHIFT 1 014 LSHIFT 1 015 LSHIFT 1 016 LSHIFT OR OR OR OR CONSTANT USBPORTUSBCHANGEBITS

0700 CONSTANT USBTRBBUFF       ( from FORTH Memory map !?)
0720 CONSTANT USBEVENTTRBBUFF  ( from FORTH Memory map !?)
0740 CONSTANT USBEVENTORGTRBBUFF  ( from FORTH Memory map !?)
0760 CONSTANT USBSLOTCTXBUFF   ( from FORTH Memory map !?) ( 50 bytes!?)
07A0 CONSTANT USBEPCTXBUFF     ( from FORTH Memory map !?) ( 51 bytes!?)
07E0 CONSTANT USBSLOTCTXBUFF2   ( from FORTH Memory map !?) ( 50 bytes!?)
0820 CONSTANT USBEPCTXBUFF2     ( from FORTH Memory map !?) ( 51 bytes!?)

: USBTRBSETSTYPE  ( n1 -- n2 )
   01F AND 010 LSHIFT ;

: USBTRBGETTYPE  ( n1 -- n2 )
   03F 0A LSHIFT AND 0A RSHIFT ;

: USBTRBSETTYPE  ( n1 -- n2 )
   03F AND 0A LSHIFT ;

: USBTRBGETCOMPCODE  ( n1 -- n2 )
   07F 018 LSHIFT AND 018 RSHIFT ;

: USBTRBGETSLOT  ( n1 -- n2 )
   0FF 018 LSHIFT AND 018 RSHIFT ;

: USBTRBSETSLOT  ( n1 -- n2 )
   0FF AND 018 LSHIFT ;

( TToggleCyleOff | On !? and several are zeros! TRBCYCLEON !? ) 
6 USBTRBSETTYPE 1 OR CONSTANT USBTRBLINKCMND

1 01F LSHIFT CONSTANT USBRESPDONE 

020 CONSTANT USBMAXDEVCNT  

( portinfo)
CREATE USBPI 020 4 * ALLOT

: USBPICL  ( -- )
   USBPI 020 4 * ERASE ;

: USBPIIDX  ( idx -- addr )
   2 LSHIFT USBPI + ;

: USBISUSB3PORT  ( n -- flag )
   USBPIIDX C@ 1 AND 1 = ;
   
: USBISUSB2PORT  ( n -- flag )
   USBPIIDX C@ 1 AND 0 = ;

: USBISUSB2HSO  ( n -- flag )
   USBPIIDX C@ 2 AND 2 = ;

: USBHASPAIR  ( n -- flag )
   USBPIIDX C@ 4 AND 4 = ;

: USBISACTIVE  ( n -- flag )
   USBPIIDX C@ 8 AND 8 = ;

020 CONSTANT USBMAXDEVCNT   ( could be 127, but external HUBs are supported)

CREATE USBCUREPRINGPTRARR USBMAXDEVCNT CELLS ALLOT
CREATE USBCUREPRINGCYCLEARR USBMAXDEVCNT ALLOT

: USBCLCUREPRINGPTRARR  ( -- )
   USBCUREPRINGPTRARR USBMAXDEVCNT CELLS ERASE 
   USBCUREPRINGCYCLEARR USBMAXDEVCNT ERASE ;

VARIABLE USBCUREPRINGPTR
VARIABLE USBCUREPRINGCYCLE	

: USBSACUREPRINGPTR  ( slotID -- )
   1- DUP USBMAXDEVCNT U>= IF DROP EXIT THEN 
   DUP >R 2 LSHIFT USBCUREPRINGPTRARR + USBCUREPRINGPTR @ SWAP ! 
   R> USBCUREPRINGCYCLEARR + USBCUREPRINGCYCLE @ SWAP C! ;

: USBGCUREPRINGPTR  ( slotID -- )
   1- DUP USBMAXDEVCNT U>= IF DROP EXIT THEN 
   DUP >R 2 LSHIFT USBCUREPRINGPTRARR + @ USBCUREPRINGPTR ! 
   R> USBCUREPRINGCYCLEARR + C@ USBCUREPRINGCYCLE ! ;

VARIABLE USBCURHEAPPTR	
VARIABLE USBCURHEAPPTRSAVED	
( USBHEAPINIT USBCURHEAPPTR !)
VARIABLE USBINITEDMSD
( 0FF USBINITEDMSD !)

VARIABLE USBBASE4BITS 
VARIABLE USBBASE0

VARIABLE USBOPBASEOFFS 

: USBEBUSMASTER  ( b d f -- )
   4 6 PCICFGWRW ;

: USBGBASE  ( b d f -- )
   010 PCICFGRDD DUP 
   0F AND USBBASE4BITS ! 
   0F INVERT AND USBBASE0 ! ;

: USBFLADJ   ( b d f -- )
   061 020 PCICFGWRB ;

: USBGVER?  ( -- flag )
   USBBASE0 @ 2 + W@ 095 U< ; 

: USBGUP32BITS  ( b d f -- n )
   014 PCICFGRDD ;

: USBPANTHERPOINT  ( b d f -- )
   3DUP 0 PCICFGRDW 08086 = 
   IF 
      3DUP 2 PCICFGRDW 01E31 =
      IF 
        3DUP 8 PCICFGRDB 4 = 
        IF 
          3DUP 0D8 FFFFFFFF PCICFGWRD  
               0D0 FFFFFFFF PCICFGWRD  
        THEN
      THEN 
   THEN 3DROP ;

: USBCBASEOFF  ( -- )
   USBBASE0 @ C@ USBOPBASEOFFS ! ;

: USBRESETCTRL?  ( -- flag )
   USBBASE0 @ USBOPBASEOFFS @ + DUP 2 SWAP ! 
   TRUE SWAP 01F4 0 DO DUP @ 2 AND 0= IF NIP FALSE SWAP LEAVE THEN 1 SLEEP LOOP DROP ;

VARIABLE USBHCCPARAMS1 
VARIABLE USBHCCPARAMS2 
VARIABLE USBHCSPARAMS1 
VARIABLE USBHCSPARAMS2 
VARIABLE USBRTSOFF
VARIABLE USBDBOFF
VARIABLE USBEXTCAPSOFF 
VARIABLE USBCTXSIZE 

: USBCEXTCAPSREGS  ( -- )
   USBBASE0 @ 010 + @ USBHCCPARAMS1 !
   USBBASE0 @ 01C + @ USBHCCPARAMS2 !
   USBBASE0 @ 4 + @ USBHCSPARAMS1 !
   USBBASE0 @ 8 + @ USBHCSPARAMS2 !
   USBBASE0 @ 018 + @ 01F INVERT AND USBRTSOFF !
   USBBASE0 @ 014 + @ 03 INVERT AND USBDBOFF !
   USBHCCPARAMS1 @ FFFF0000 AND 010 RSHIFT 2 LSHIFT USBEXTCAPSOFF ! 
   USBHCCPARAMS1 @ 4 AND 0= IF 020 ELSE 040 THEN USBCTXSIZE ! ;

: USBFINDLEGACY  ( -- addr TRUE )   ( -- FALSE )
   USBBASE0 @ USBEXTCAPSOFF @ + 
   BEGIN
     DUP C@ 1 = 
     IF TRUE EXIT THEN  
     DUP @ 8 RSHIFT 0FF AND DUP 0= 
     IF CR ." No legacy support" CR 2DROP FALSE EXIT THEN 
     2 LSHIFT +
   AGAIN ;

: USBSTOPLEGACY  ( -- flag )  ( TRUE on success)
   USBFINDLEGACY ( addr flag )
   IF DUP DUP @ 01000000 OR SWAP ! 
     0A 0 
     DO
       DUP @ 01010000 AND 01000000 = 
       IF DROP TRUE UNLOOP EXIT THEN 
       1 SLEEP
     LOOP 
     DROP FALSE
   ELSE TRUE 
   THEN ;

VARIABLE USBNDP   ( number of downstream ports)

VARIABLE USBPORTSUSB2
VARIABLE USBPORTSUSB3

: USBGPROTOOFFSET  ( listoff version -- next flags offset count )
   >R 
   BEGIN
     DUP DUP USBBASE0 @ + 1+ C@ DUP 0<> ( listoff listoff item_next flag )
     IF 2 LSHIFT +           ( listoff next )
     ELSE 2DROP 0            ( listoff next[0] )
     THEN
     OVER USBBASE0 @ + DUP C@ 2 = SWAP 3 + C@ R@ = AND 
     IF   ( listoff next )  ( R: version )
       R> DROP SWAP USBBASE0 @ + DUP >R 0A + W@ 0FFF AND   ( next flags ) ( R: base+listoff )
       R@ 8 + C@ 1- ( next flags offset ) ( R: base+listoff )
       R> 9 + C@        ( next flags offset count )
       EXIT       
     THEN
     NIP
   DUP 0= UNTIL 
   R> DROP 0 0 0 ;

: USBGPORTCNT   ( -- )
   USBHCSPARAMS1 @ FF000000 AND 018 RSHIFT USBNDP ! ;

( find the USB 2.0 ports and mark the port_info byte as USB2 if found)
: USBFINDUSB2PORTS   ( -- )
   USBEXTCAPSOFF @ DUP 0<>
   IF        ( next )
     BEGIN
       2 USBGPROTOOFFSET ( next flags offset count ) 
       DUP 0<>
       IF 
         0 DO    ( next flags offset )
             DUP I + USBPIIDX DUP ( next flags offset PI[4*[offset+i]] PI[4*[offset+i]] )
             2 + USBPORTSUSB2 @ SWAP C!
             1 USBPORTSUSB2 +!
             DUP 0 SWAP C!
          ( next flags offset PI[4*[offset+i]] )
             >R OVER 2 AND R> SWAP 
             IF DUP C@ 2 OR SWAP C! 
             ELSE DROP 
             THEN
           LOOP
           2DROP
       ELSE 3DROP
       THEN  ( next )
       DUP 0=
     UNTIL 
   THEN
   DROP ;

( find the USB 3.0 ports and mark the port_info byte as USB3 if found)
: USBFINDUSB3PORTS   ( -- )
   USBEXTCAPSOFF @ DUP 0<>
   IF        ( next )
     BEGIN
       3 USBGPROTOOFFSET ( next flags offset count ) 
       DUP 0<>
       IF 
         0 DO    ( next flags offset )
             DUP I + USBPIIDX DUP ( next flags offset PI[4*[offset+i]] PI[4*[offset+i]] )
             2 + USBPORTSUSB3 @ SWAP C!
             1 USBPORTSUSB3 +!
             1 SWAP C!
           LOOP
           2DROP 
       ELSE 3DROP
       THEN  ( next )
       DUP 0=
     UNTIL 
   THEN
   DROP ;

( pair up each USB3 port with it's companion USB2 port)
: USBPAIRUPUSB2USB3  ( -- )
   USBNDP @ 0 
   DO 
     USBNDP @ 0 
     DO 
       I USBPIIDX 2 + C@ J USBPIIDX 2 + C@ = 
       I USBPIIDX C@ 1 AND J USBPIIDX C@ 1 AND <> AND 
       IF 
         I J USBPIIDX 1 + C!
         J USBPIIDX DUP C@ 4 OR SWAP C!
         J I USBPIIDX 1 + C!
         I USBPIIDX DUP C@ 4 OR SWAP C!
       THEN 
     LOOP 
   LOOP ;

( mark all USB3 ports and any USB2 only ports as active, deactivating any USB2 ports that have a USB3 companion)
: USBMARKPORTS  ( -- )
   USBNDP @ 0 
   DO 
     I USBISUSB3PORT I USBISUSB2PORT I USBHASPAIR INVERT AND OR 
     IF 
       I USBPIIDX DUP C@ 8 OR SWAP C! 
     THEN 
   LOOP ;

VARIABLE USBPAGESIZE
VARIABLE USBMAXSLOTS 
VARIABLE USBDCBAAPSTART 

( get the page size of the controller)
: USBGPAGESIZE  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + 8 + @ 0FFFF AND 0C LSHIFT USBPAGESIZE ! ;

: USBGMAXSLOTS   ( -- )
   USBHCSPARAMS1 @ 0FF AND USBMAXSLOTS ! ;

: USBALHEAP   ( size alignment boundary -- memaddr )
   SWAP 1- DUP USBCURHEAPPTR @ + SWAP INVERT AND USBCURHEAPPTR !
   SWAP 3 + 3 INVERT AND  ( boundary size )
   SWAP DUP 0>
   IF 
     DUP 1- USBCURHEAPPTR @ + OVER 1- INVERT AND  ( size boundary NextBoundary )
     >R 2DUP    ( size boundary size boundary )  ( R: NextBoundary )
     SWAP USBCURHEAPPTR @ + SWAP > R> SWAP ( size boundary NextBdry flag )
     IF USBCURHEAPPTR ! ELSE DROP THEN 
   THEN
   ( size boundary )
   >R DUP USBCURHEAPPTR @ + 1- USBHEAPLIMIT U>= OVER R@ 0> SWAP R> U> AND OR
   ABORT" Error in allocating memory within our heap! "
   ( size )
   USBCURHEAPPTR @ OVER ERASE 
   USBCURHEAPPTR @ SWAP USBCURHEAPPTR +! ;

: USBALDCBAAPSTART  ( -- )
   0800 040 USBPAGESIZE @ USBALHEAP USBDCBAAPSTART ! ;

: USBDOHI32  ( addr -- addr+CELL )
   CELL+ USBHCCPARAMS1 @ 1 AND 0<> IF DUP 0 SWAP ! THEN ;

: USBSOPSUSBDCBAAP  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + 030 + USBDCBAAPSTART @ OVER ! USBDOHI32 DROP ;

: USBALSCRATCHPAD   ( -- )
    USBHCSPARAMS2 @ F8000000 AND 01B RSHIFT ( maxscrpbuffs )
    DUP 0> 
    IF DUP DUP 3 LSHIFT 040 USBPAGESIZE @ USBALHEAP             ( maxscrpbuffs maxscrpbuffs scrpbuffarrstart )
      SWAP USBPAGESIZE @ * USBPAGESIZE @ 0 USBALHEAP           ( maxscrpbuffs scrpbuffarrstart scrpbuffstart )
      OVER USBDCBAAPSTART @ ! USBDCBAAPSTART @ USBDOHI32 DROP  ( maxscrpbuffs scrpbuffarrstart scrpbuffstart )
      ROT                 ( scrpbuffarrstart scrpbuffstart maxscrpbuffs )
      0 DO                ( scrpbuffarrstart scrpbuffstart )
          2DUP I USBPAGESIZE @ * + SWAP I 3 LSHIFT + DUP >R ! R> USBDOHI32 DROP 
        LOOP DROP
    THEN DROP ;

( Not used)
( : USBCLSEGS)  ( -- )
(   USBTRRINGSEGMENTS USBMAXSEGMENTCNTPERTRRING CELLS ERASE )
(   USBTRRINGSEGMENTCNTS USBMAXSEGMENTCNTPERTRRING CELLS ERASE ;)

VARIABLE IVAR

: USBALRINGSEGS  ( n -- )
   DUP 4 LSHIFT 040 010000 USBALHEAP USBTRRINGSEGMENTS IVAR @ 2 LSHIFT DUP >R + ! USBTRRINGSEGMENTCNTS R> + ! ;

: USBSETLINKTRBS  ( n -- )
   0 DO USBTRRINGSEGMENTS I 2 LSHIFT + @ USBTRRINGSEGMENTCNTS I 2 LSHIFT + @   ( ptrToSeg #TRBs ) 
        1- 4 LSHIFT + ( ptrToLastTRBInSeg )
        I 1+ 2 LSHIFT USBTRRINGSEGMENTS + @ ( ptrToLastTRBInseg ptrToNextSeg )
         OVER ! USBDOHI32 
        ( status)   ( ptrToLastTRBInSeg+CELL )
        CELL+ DUP 0 SWAP ! CELL+ USBTRBLINKCMND SWAP ! 
     LOOP ;

: USBSETLASTLINKTRB  ( n -- )
   1- 2 LSHIFT DUP >R USBTRRINGSEGMENTS + @ R> USBTRRINGSEGMENTCNTS + @ 1- 4 LSHIFT + ( ptrToLastTRBInSeg )
   USBTRRINGSEGMENTS @ OVER ! USBDOHI32                                               ( ptrToLastTRBInSeg+CELL )
   CELL+ DUP 0 SWAP ! CELL+ USBTRBLINKCMND 2 OR SWAP ! ;

: USBCRRING  ( n -- memaddr )
   USBMAXTRBCNTPERTRRING /MOD    ( rem quot )
   2DUP SWAP 0> IF 1+ THEN         ( rem quot quot|+1 )
   USBMAXSEGMENTCNTPERTRRING U> IF DROP USBMAXSEGMENTCNTPERTRRING OVER 0<> IF 1- THEN THEN 
   ( rem quot ) 
   SWAP OVER 0>  ( quot rem flag ) 
   IF OVER 0 DO I IVAR ! USBMAXTRBCNTPERTRRING USBALRINGSEGS LOOP THEN
   ( quot rem )
   DUP 0> IF OVER IVAR ! DUP USBALRINGSEGS THEN 
   0> IF 1+ THEN       ( segcnt )
   DUP 0= IF DROP EXIT THEN 
   DUP 1 > IF DUP 1- USBSETLINKTRBS THEN
   USBSETLASTLINKTRB USBTRRINGSEGMENTS @ ;

: USBCREVENTRING  ( n -- tableaddr addr )
   040 040 0 USBALHEAP                 ( n tableaddr )
   OVER 4 LSHIFT 040 010000 USBALHEAP  ( n tableaddr addr )
   2DUP SWAP ! SWAP DUP >R USBDOHI32   ( n addr tableaddr+CELL ) ( R: tableaddr )
   SWAP ROT ROT   ( addr n tableaddr+CELL )
   CELL+ DUP >R ! R> CELL+ 0 SWAP ! R> SWAP ;

VARIABLE USBCMNDRINGADDR
VARIABLE USBCMNDTRBADDR 
VARIABLE USBCMNDTRBCYCLE 
VARIABLE USBCUREVENTRINGADDR 
VARIABLE USBEVENTRINGTABLEADDR 
VARIABLE USBCUREVENTRINGCYCLE 

: USBCRCMDRING  ( -- )
   USBCMNDRINGTRBS USBCRRING DUP USBCMNDRINGADDR ! USBCMNDTRBADDR ! 
   1 USBCMNDTRBCYCLE ! ;

: USBINITITERRUPTERS  ( -- )
   01000 USBCREVENTRING USBCUREVENTRINGADDR ! USBEVENTRINGTABLEADDR ! 
   1 USBCUREVENTRINGCYCLE !
   USBBASE0 @ USBRTSOFF @ + 020 + 
  ( IMAN: 31:2 ResvdP)
   DUP 0 + DUP @ FFFFFFFC AND 1 OR SWAP ! 
   0 OVER 4 + !
  ( EVENTRINGSEGTABLESIZE: 31:16 ResvdP)
   DUP 8 + DUP @ FFFF0000 AND 1 OR SWAP ! 
   USBCUREVENTRINGADDR @ 8 OR OVER 018 + !
   DUP 018 + USBDOHI32 DROP 
  ( EVENTRINGSEGTABLEADDR: 5:0 ResvdP)
   DUP 010 + DUP @ 01F AND USBEVENTRINGTABLEADDR @ OR SWAP ! 
   010 + USBDOHI32 DROP ;

: USBINITUSBCRCR  ( -- )
   USBBASE0 @ USBOPBASEOFFS @ + 018 + USBCMNDRINGADDR @ 1 OR OVER ! USBDOHI32 DROP ;

: USBINITUSBCFG  ( -- )
   USBMAXSLOTS @ USBBASE0 @ USBOPBASEOFFS @ + 038 + ! ;

: USBINITUSBDNCRTL  ( -- )
   2 USBBASE0 @ USBOPBASEOFFS @ + 014 + ! ;

: USBDOPORTS  ( -- )
   USBGPORTCNT ." Found (virtual) root hub ports: " USBNDP @ .  
   USBNDP @ 020 U>= ABORT" Root-hub port-num >= allocated port_num array" CR 
   0 USBPORTSUSB2 ! 0 USBPORTSUSB3 ! USBFINDUSB2PORTS USBFINDUSB3PORTS 
   USBPAIRUPUSB2USB3 USBMARKPORTS ; 

: USBCLSTATUS  ( -- )
   1 0A LSHIFT 1 4 LSHIFT 1 3 LSHIFT 1 2 LSHIFT OR OR OR USBBASE0 @ USBOPBASEOFFS @ + 4 + ! ;

: USBSTARTSCHEDULE  ( -- )
   1 2 LSHIFT 1 OR USBBASE0 @ USBOPBASEOFFS @ + ! ;

: USBCLPORTSTATUS  ( portscAddr -- )
   1 9 LSHIFT USBPORTUSBCHANGEBITS OR SWAP ! ;

: USBRESPORTU2U3  ( portscAddr port -- )
   USBISUSB3PORT 1 9 LSHIFT SWAP 
   IF 1 01F LSHIFT OR SWAP ! 
   ELSE 1 4 LSHIFT OR SWAP ! 
   THEN ;

: USBWAITBIT21  ( portscAddr -- flag )
   FALSE 01F4 0 DO OVER @ 1 015 LSHIFT AND 0<> IF DROP TRUE LEAVE THEN 1 SLEEP LOOP NIP ; 

: USBDOTO  ( portscAddr TOFlag -- retFlag )
   IF 3 SLEEP DUP @ 2 AND 0<> 
    IF 1 9 LSHIFT USBPORTUSBCHANGEBITS OR SWAP ! TRUE 
    ELSE DROP FALSE
    THEN 
   ELSE DROP FALSE 
   THEN ;

: USBUSB2PORTACT   ( port retFlag -- )
   OVER USBISUSB2PORT AND 
   IF USBPIIDX DUP DUP DUP 
      C@ 8 OR SWAP C! 
      C@ 4 AND 0<> 
      IF 1 + C@ USBPIIDX  
         DUP C@ 8 INVERT AND SWAP C! 
      ELSE DROP
      THEN 
   ELSE DROP
   THEN ;

: USBUSB3PORTACT   ( port retFlag -- )
   INVERT OVER USBISUSB3PORT AND 
   IF USBPIIDX DUP DUP C@  
      8 INVERT AND SWAP C!
      1 + C@ USBPIIDX  
      DUP C@ 8 OR SWAP C! 
   ELSE DROP
   THEN ;

: USBCPORTST  ( port -- addr )
   4 LSHIFT USBBASE0 @ USBOPBASEOFFS @ + + 0400 + ; 

: USBRESETPORT  ( port -- flag )
   DUP USBCPORTST DUP @ 1 9 LSHIFT AND 0=
  ( port portsc flag )
   IF 1 9 LSHIFT OVER ! 014 SLEEP DUP @ 1 9 LSHIFT AND 0= 
     IF 2DROP FALSE EXIT THEN 
   THEN    ( port portsc )
   DUP USBCLPORTSTATUS 2DUP SWAP USBRESPORTU2U3 ( port portsc )
   DUP USBWAITBIT21       ( port portsc TOflag ) 
   USBDOTO                ( port retFlag ) 
   2DUP USBUSB2PORTACT SWAP OVER USBUSB3PORTACT ;

: USBCLDEVDESC  ( -- )
   DEVDESCBUFF 012 ERASE ; 

: USBGSPEED  ( portstAddr -- speed )
   @ 0F 0A LSHIFT AND 0A RSHIFT ;

: USBSTRB   ( cmd status paramHI paramLO addrTRB -- )
   SWAP OVER ! CELL+ SWAP OVER ! CELL+ SWAP OVER ! CELL+ ! ;

VARIABLE USBORGTRBADDR 

: USBCPTRB  ( from to -- )
(   010 CMOVE ;) ( !!!Must write param and status fields before cmd)
   OVER @ OVER !
   OVER CELL+ @ OVER CELL+ !
   OVER 8 + @ OVER 8 + !
   SWAP 0C + @ SWAP 0C + ! ;

: USBACMDTRB   ( trbAddr -- )
   USBCMNDTRBADDR @ USBCPTRB  
   USBCMNDTRBADDR @ 0C + USBCMNDTRBCYCLE @ OVER @ OR SWAP !
   010 USBCMNDTRBADDR +! ;

: USBCHKCMDLINKTRB  ( -- )
   USBCMNDTRBADDR @ 0C + DUP @ DUP USBTRBGETTYPE 6 = 
  ( cmdoffsAddr cmd flag )
  IF SWAP OVER 1 INVERT AND USBCMNDTRBCYCLE @ OR SWAP ! ( cmd )
     USBCMNDTRBADDR @ @ USBCMNDTRBADDR !
     2 AND 0<>
     IF USBCMNDTRBCYCLE @ 1 XOR USBCMNDTRBCYCLE ! THEN 
  ELSE 2DROP 
  THEN ;

: USBRINGCMD  ( -- )
   0 USBBASE0 @ USBDBOFF @ + ! ;

: USBRINGCTRLEP  ( slotid -- )
   1 SWAP 2 LSHIFT USBBASE0 @ USBDBOFF @ + + ! ;

: USBPOLL   ( ms -- flagTO )
   TRUE SWAP 0 
   DO USBCUREVENTRINGADDR @ USBEVENTTRBBUFF USBCPTRB 
      USBEVENTTRBBUFF 0C + @ 1 AND USBCUREVENTRINGCYCLE @ = 
      IF DROP FALSE LEAVE THEN 1 SLEEP 
   LOOP DUP IF ." USB xHCI Command Interrupt wait TO (Polling) " THEN ;

: USBCLRESPDONE  ( -- )
    USBTRBBUFF 8 + DUP @ USBRESPDONE INVERT AND SWAP ! ;

: USBCHKRESPDONE?  ( statusAddr -- flag )
    @ USBRESPDONE AND 0= ;

: USBTRB?  ( -- flag )
  USBCUREVENTRINGADDR @ USBEVENTTRBBUFF USBCPTRB 
  USBEVENTTRBBUFF 0C + @ 1 AND USBCUREVENTRINGCYCLE @ = ;

: USBCPSLOT  ( addrTRBFrom addrTRBTo -- )
    DUP >R 0C + @ 0FFFFFF AND 
    OVER 0C + @ FF000000 AND OR 
    R@ 0C + ! 
    8 + @ R> 8 + ! ;

: USBHANDLETRBTYPE  ( addrTRB -- )
  DUP 0C + @ USBTRBGETTYPE 021 =
  IF
    DUP @            ( addrTRB orgAddr )
    DUP USBEVENTORGTRBBUFF USBCPTRB   ( addrTRB orgAddr )
    USBEVENTORGTRBBUFF 0C + @ 
    USBTRBGETTYPE 9 =
    IF    ( addrTRB orgAddr )
      OVER USBEVENTORGTRBBUFF USBCPSLOT 
    ELSE
      OVER 8 + @ USBEVENTORGTRBBUFF 8 + ! 
    THEN  ( addrTRB orgAddr )
    USBEVENTORGTRBBUFF 8 + DUP @ USBRESPDONE OR SWAP ! 
    ( addrTRB orgAddr )
    USBEVENTORGTRBBUFF SWAP USBCPTRB 
  THEN DROP ;

: USBADVANCEDQPTR  ( addr -- )
  1 3 LSHIFT OR USBBASE0 @ USBRTSOFF @ + 020 + 
  SWAP OVER ! USBDOHI32 DROP ;

: USBHANDLERESPONSE  ( -- )
  1 SLEEP 
  USBCUREVENTRINGADDR @   ( lastaddr )
  USBTRB?
  IF        ( lastaddr )
    BEGIN
      USBEVENTTRBBUFF 0C + @ 1 2 LSHIFT AND 0= 
      IF 
        USBEVENTTRBBUFF 8 + @ USBTRBGETCOMPCODE
        1 =
        IF 
   USBEVENTTRBBUFF USBHANDLETRBTYPE THEN
      ELSE
        USBEVENTTRBBUFF 0C + @ USBTRBGETTYPE 
        020 = 
        IF 
          USBEVENTTRBBUFF 8 + @ USBRESPDONE OR 
          USBEVENTTRBBUFF @ !
        THEN 
      THEN
      DROP USBCUREVENTRINGADDR @  
      010 USBCUREVENTRINGADDR +!
      USBTRB? INVERT 
    UNTIL
  THEN 
  USBADVANCEDQPTR ; 

: USBSENDCMD   ( flagRing trbAddr -- flagTO )
    USBCMNDTRBADDR @ USBORGTRBADDR ! 
    USBACMDTRB USBCHKCMDLINKTRB 
    IF  ( ring)
      USBRINGCMD 07D0 USBPOLL IF TRUE EXIT THEN USBHANDLERESPONSE
      USBORGTRBADDR @ 8 + USBCHKRESPDONE? 
      IF CR ." DONE-bit not set! " TRUE EXIT THEN 
      USBORGTRBADDR @ USBTRBBUFF USBCPTRB USBCLRESPDONE FALSE
    ELSE FALSE 
    THEN ;

: USBGMPS  ( speed -- mps )
    CASE
      2 OF >R    8 R> ENDOF
      1 OF >R  040 R> ENDOF
      3 OF >R  040 R> ENDOF
      4 OF >R 0200 R> ENDOF
    ENDCASE ;

VARIABLE USBPORT
VARIABLE USBSLOTID
VARIABLE USBMPS
VARIABLE USBSPEED

: USBCLSLOT  ( -- )
   USBSLOTCTXBUFF 032 ERASE ;

: USBFILLSLOT  ( -- )
   1 USBSLOTCTXBUFF !
   USBSPEED @ USBSLOTCTXBUFF 6 + !
   USBPORT @ 1+ USBSLOTCTXBUFF 012 + !
   0 USBSLOTCTXBUFF 01A + !
   0 USBSLOTCTXBUFF 02A + ! ;

: USBWRITETOSLOT  ( slotBuff offset -- )  ( i.e. from to)
    OVER ( slotBuff offset slotBuff )
    DUP @ 01B LSHIFT 
    SWAP DUP 4 + C@ 01A LSHIFT 
    SWAP DUP 5 + C@ 019 LSHIFT 
    SWAP DUP 6 + @ 014 LSHIFT 
    SWAP 0A + @ 
    OR OR OR OR   ( slotBuff offset value )
    OVER ! CELL+  ( slotBuff offset+ )
    OVER ( slotBuff offset slotBuff )
    DUP 0E + @ 018 LSHIFT 
    SWAP DUP 012 + @ 010 LSHIFT 
    SWAP 016 + @  
    OR OR         ( slotBuff offset value )
    OVER ! CELL+  ( slotBuff offset+ )
    OVER ( slotBuff offset slotBuff )
    DUP 01A + @ 016 LSHIFT 
    SWAP DUP 01E + @ 010 LSHIFT 
    SWAP DUP 022 + @ 8 LSHIFT 
    SWAP 026 + @ 
    OR OR OR      ( slotBuff offset value )
    OVER ! CELL+  ( slotBuff offset+ )
    OVER   ( slotBuff offset slotBuff )
    DUP  02A + @ 01B LSHIFT 
    SWAP 02E + @ 
    OR     ( slotBuff offset value )
    SWAP ! DROP ;

: USBCLEP  ( -- )
   USBEPCTXBUFF 033 ERASE ;

: USBWRITETOEP  ( epBuff offset -- )  ( i.e. from to)
   OVER ( epBuff offset epBuff )
   DUP  @ 010 LSHIFT 
   SWAP DUP 4 + C@ 0F LSHIFT 
   SWAP DUP 5 + @ 0A LSHIFT 
   SWAP DUP 9 + @ 8 LSHIFT 
   SWAP 0D + @ 
   OR OR OR OR    ( epBuff offset value )
   OVER ! CELL+   ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   DUP  011 + @ 010 LSHIFT 
   SWAP DUP 015 + @ 8 LSHIFT 
   SWAP DUP 019 + C@ 7 LSHIFT 
   SWAP DUP 01A + @ 3 LSHIFT 
   SWAP 01E + @ 1 LSHIFT  
   OR OR OR OR   ( epBuff offset value )
   OVER ! CELL+  ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   DUP  022 + @  
   SWAP 02A + C@  
   OR   ( epBuff offset value )
   OVER ! CELL+     ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   026 + @ 
   OVER ! CELL+  ( epBuff offset+ )
   OVER ( epBuff offset epBuff )
   DUP  02B + @  
   SWAP 02F + @  
   OR   ( epBuff offset value )
   SWAP ! DROP ;

: USBREADFROMSLOT  ( offset slotBuff -- )  ( i.e from to)
   OVER @ 01F 01B LSHIFT AND 01B RSHIFT
   OVER !
   OVER @ 1 01A LSHIFT AND 01A RSHIFT
   OVER 4 + C!
   OVER @ 1 019 LSHIFT AND 019 RSHIFT
   OVER 5 + C!
   OVER @ 0F 014 LSHIFT AND 014 RSHIFT
   OVER 6 + !
   OVER @ 0FFFFF AND 
   OVER 0A + !
   SWAP CELL+ SWAP
   OVER @ 0FF 018 LSHIFT AND 018 RSHIFT
   OVER 0E + !
   OVER @ 0FF 010 LSHIFT AND 010 RSHIFT
   OVER 012 + !
   OVER @ 0FFFF AND
   OVER 016 + !
   SWAP CELL+ SWAP
   OVER @ 03FF 016 LSHIFT AND 016 RSHIFT
   OVER 01A + !
   OVER @ 3 010 LSHIFT AND 010 RSHIFT
   OVER 01E + !
   OVER @ 0FF 8 LSHIFT AND 8 RSHIFT
   OVER 022 + !
   OVER @ 0FF AND
   OVER 026 + !
   SWAP CELL+ SWAP
   OVER @ 01F 01B LSHIFT AND 01B RSHIFT
   OVER 02A + !
   OVER @ 0FF AND
   OVER 02E + ! 2DROP ; 

: USBREADFROMEP  ( offset epBuff -- )  ( i.e. from to)
   OVER @ 0FF 010 LSHIFT AND 010 RSHIFT
   OVER !
   OVER @ 1 0F LSHIFT AND 0F RSHIFT
   OVER 4 + C!
   OVER @ 01F 0A LSHIFT AND 0A RSHIFT
   OVER 5 + !
   OVER @ 3 8 LSHIFT AND 8 RSHIFT
   OVER 9 + !
   OVER @ 7 AND
   OVER 0D + !
   SWAP CELL+ SWAP
   OVER @ 0FFFF 010 LSHIFT AND 010 RSHIFT
   OVER 011 + !
   OVER @ 0FF 8 LSHIFT AND 8 RSHIFT
   OVER 015 + !
   OVER @ 1 7 LSHIFT AND 7 RSHIFT
   OVER 019 + C!
   OVER @ 7 3 LSHIFT AND 3 RSHIFT
   OVER 01A + !
   OVER @ 3 1 LSHIFT AND 1 RSHIFT
   OVER 01E + !
   SWAP CELL+ SWAP
   OVER @ 0F INVERT AND 
   OVER 022 + !
   OVER @ 1 AND 
   OVER 02A + C!
   SWAP CELL+ SWAP
   OVER @  
   OVER 026 + !
   SWAP CELL+ SWAP
   OVER @ 0FFFF 010 LSHIFT AND 010 RSHIFT
   OVER 02B + !
   OVER @ 0FFFF AND 
   OVER 02F + ! 2DROP ; 

: USBSETADDRESS  ( slotAddr blockIt -- retFlag )
   USBCTXSIZE @ 5 LSHIFT 040 USBPAGESIZE @ USBALHEAP 
   ( slotAddr blockIt address )
   0 OVER ! 3 OVER CELL+ !
   ( slotAddr blockIt address )
   USBSLOTCTXBUFF OVER USBCTXSIZE @ + USBWRITETOSLOT 
   ( slotAddr blockIt address )
   USBEPCTXBUFF OVER USBCTXSIZE @ + 1 USBCTXSIZE @ * + USBWRITETOEP 
   ( slotAddr blockIt address )
   >R 9 LSHIFT USBSLOTID @ USBTRBSETSLOT 0B 
      USBTRBSETTYPE OR OR 0 0 R> USBTRBBUFF USBSTRB
   ( slotAddr )
   TRUE USBTRBBUFF USBSENDCMD IF DROP FALSE EXIT THEN 
   USBTRBBUFF 8 + @ USBTRBGETCOMPCODE 1 = 
   IF    ( slotAddr )
     DUP 
     USBSLOTCTXBUFF2 USBREADFROMSLOT 
     USBSLOTCTXBUFF2 02A + @ 
     USBSLOTCTXBUFF 02A + ! 
     USBSLOTCTXBUFF2 02E + @ 
     USBSLOTCTXBUFF 02E + ! 
     ( slotAddr )
     USBCTXSIZE @ 1 * + USBEPCTXBUFF2 USBREADFROMEP 
     USBEPCTXBUFF2 0D + @ 
     USBEPCTXBUFF 0D + ! 
     USBEPCTXBUFF2 011 + @ 
     USBEPCTXBUFF 011 + ! 
     TRUE
   ELSE DROP FALSE
   THEN ;

: USBINITEP   ( slotAddr epnum epinterval type -- )
   0 <> IF DROP 2DROP EXIT THEN 
   USBCLEP USBTRBSPERRING USBCRRING
   DUP USBCUREPRINGPTR ! 1 USBCUREPRINGCYCLE !
   USBEPCTXBUFF 022 + !
   0 USBEPCTXBUFF 026 + !
   USBCUREPRINGCYCLE @ USBEPCTXBUFF 02A + C!
   USBMPS @ USBEPCTXBUFF 011 + !
   0 USBEPCTXBUFF 0D + !
   4 USBEPCTXBUFF 01A + !
   8 USBEPCTXBUFF 02F + !
   3 USBEPCTXBUFF 01E + !
   USBEPCTXBUFF ! ( slotAddr epnum )
   USBCTXSIZE @ * + USBEPCTXBUFF SWAP USBWRITETOEP ;

: USBINITSLOT  ( -- slotAddr )
   USBCTXSIZE @ 2* 020 USBPAGESIZE @ USBALHEAP   ( slotAddr )
   DUP USBDCBAAPSTART @ USBSLOTID @ 3 LSHIFT + ! ( slotAddr )
   USBCLSLOT USBFILLSLOT USBSLOTCTXBUFF OVER  ( slotAddr slotBuff slotAddr )
   USBWRITETOSLOT ( slotAddr ) 
   DUP 1 0 0 USBINITEP ;

: USBSAHEAPPTR   ( -- )
   USBCURHEAPPTR @ USBCURHEAPPTRSAVED ! ;

: USBRHEAPPTR   ( -- )
   USBCURHEAPPTRSAVED @ USBCURHEAPPTR ! ;

: USBPDIR  ( dir len -- dirCtrlr )
   0= 
   IF DROP 0 
   ELSE  
     IF 3 ELSE 2 THEN 
   THEN ;

: USBCHKEPLINK  ( addrRingPtr addrCycle -- )
   >R DUP @ 0C + DUP @ DUP USBTRBGETTYPE 6 = 
  ( addrRingPtr cmdoffsAddr cmd flag )  ( R: addrCycle )
  IF SWAP OVER 1 INVERT AND R@ @ OR SWAP ! 
    ( addrRingPtr cmd ) ( R: addrCycle )
     OVER @ @ ROT ! R> SWAP
    ( addrCycle cmd ) 
     2 AND 0<>
     IF DUP @ 1 XOR SWAP ! ELSE DROP THEN 
  ELSE R> 2DROP 2DROP 
  THEN ;

VARIABLE USBEPRINGPTR
VARIABLE USBEPRINGCYCLE

: USBINCEPRINGPTR  ( -- )
   USBEPRINGPTR USBEPRINGCYCLE OVER 010 SWAP @ +! USBCHKEPLINK ;

: USBSETUPSTAGE ( packetAddr dirCtrlr -- )
   010 LSHIFT 2 USBTRBSETTYPE 1 6 LSHIFT USBCUREPRINGCYCLE @ OR OR OR  ( packetAddr cmd )
   8      ( packetAddr cmd status )
   ROT DUP ( cmd status packetAddr packetAddr )
   6 + W@ 010 LSHIFT OVER 4 + W@ OR ( cmd status packetAddr paramHI )
   SWAP DUP 2 + W@ 010 LSHIFT SWAP DUP 1 + C@ 8 LSHIFT SWAP C@  OR OR 
  ( cmd status packetAddr paramHI paramLO )
   USBTRBBUFF USBSTRB 
   USBTRBBUFF USBCUREPRINGPTR @ USBCPTRB
   USBINCEPRINGPTR ;

: USBCREM   ( mps len -- remaining )
   OVER 1- + SWAP / 1- DUP 0< IF DROP 0 THEN ;

VARIABLE USBCTRLTRANSFER

VARIABLE USBTRBTYPE 
VARIABLE USBDIR 
VARIABLE USBDTSIZE 
VARIABLE USBDTBUFF 
VARIABLE USBREMAINING
VARIABLE USBDTBUFFORIG

: USBDATASTAGE  ( statusAddr bufferAddr dir len -- )
   USBDTSIZE ! USBDIR ! USBDTBUFF !  ( statusAddr )
   USBMPS @ USBDTSIZE @ USBCREM USBREMAINING ! ( statusAddr ) 
  BEGIN
   USBREMAINING @ 0= IF 2 ELSE 0 THEN 
   USBTRBTYPE @ USBTRBSETTYPE 
   1 4 LSHIFT USBEPRINGCYCLE @ @ OR OR OR 
   USBCTRLTRANSFER @ IF USBDIR @ 010 LSHIFT OR THEN
  ( statusAddr cmd ) 
   USBREMAINING @ 011 LSHIFT 
   USBDTSIZE @ USBMPS @ < IF USBDTSIZE @ ELSE USBMPS @ THEN 
   OR                   ( statusAddr cmd status ) 
   0 USBDTBUFF @       ( statusAddr cmd status paramHI paramLO ) 
   USBTRBBUFF USBSTRB 
   USBTRBBUFF USBEPRINGPTR @ @ USBCPTRB 
   USBMPS @ USBDTBUFF +!
   USBINCEPRINGPTR
   USBMPS @ NEGATE USBDTSIZE +!
   -1 USBREMAINING +!
   USBCTRLTRANSFER @ IF 1 USBTRBTYPE ! 0 USBDIR ! THEN 
  USBDTSIZE @ 0 <= UNTIL   ( statusAddr )
   0 OVER ! >R 
   7 USBTRBSETTYPE  1 5 LSHIFT USBEPRINGCYCLE @ @ OR OR
   0 0 R> USBTRBBUFF USBSTRB 
   USBTRBBUFF USBEPRINGPTR @ @ USBCPTRB 
   USBINCEPRINGPTR ;

: USBWAITFORRESPONSE   ( statusAddr ms -- flag )
   USBPOLL IF DROP TRUE EXIT THEN USBHANDLERESPONSE
   DUP USBCHKRESPDONE? IF ." DONE-bit not set! " DROP FALSE EXIT THEN 
   @ USBTRBGETCOMPCODE 
    CASE
      1      OF >R TRUE R> ENDOF
      0D     OF >R TRUE R> ENDOF
      6      OF >R FALSE R> ENDOF
      2 OF >R FALSE R> ENDOF
      3 OF >R FALSE R> ENDOF
    ENDCASE 
    DEPTH 0= IF FALSE ." WaitForResponse: unknown error!" THEN ;

: USBGSTSTAGEDIR   ( len dirFlag -- dirCtrlr )
   INVERT SWAP 0= OR IF 1 ELSE 0 THEN ;

: USBSTATUSSTAGE   ( dirCtrlr statusAddr -- )
   SWAP 010 LSHIFT 4 USBTRBSETTYPE 1 4 LSHIFT USBCUREPRINGCYCLE @ OR OR OR  ( statusAddr cmd )
   0         ( statusAddr cmd status )
   0 0       ( statusAddr cmd status paramHI paramLO )
   USBTRBBUFF USBSTRB     ( statusAddr )
   USBTRBBUFF USBCUREPRINGPTR @ USBCPTRB 
   USBINCEPRINGPTR 0 OVER !     ( statusAddr )
   7 USBTRBSETTYPE 1 5 LSHIFT USBCUREPRINGCYCLE @ OR OR 
   ( statusAddr cmd )
   0  ( statusAddr cmd status )
   ROT 0 SWAP    ( cmd status paramHI paramLO )
   USBTRBBUFF USBSTRB 
   USBTRBBUFF USBCUREPRINGPTR @ USBCPTRB 
   USBINCEPRINGPTR ;

VARIABLE USBSTATUSADDR
: USBGCLEAREDSTATUSADDR  ( -- addr )
   USBSTATUSADDR @ 0 OVER ! ;

: USBCTRLIO  ( destBuffAddr dirFlag[TRUE=IN] recpacket len -- flag )
   TRUE USBCTRLTRANSFER !
   USBCUREPRINGPTR USBEPRINGPTR !
   USBCUREPRINGCYCLE USBEPRINGCYCLE !
   DUP >R OVER 6 + W!  
    ( destBuffAddr dirFlag recpacket )  ( R: len )
   SWAP DUP R@ USBPDIR 
    ( destBuffAddr recpacket dirFlag dirCtrlr )  ( R: len )
   SWAP >R 
    ( destBuffAddr recpacket dirCtrlr )  ( R: len dirFlag )
   USBSETUPSTAGE      ( destBuffAddr )  ( R: len dirFlag )
   USBGCLEAREDSTATUSADDR 0100 1 0 USBALHEAP 
   DUP USBDTBUFFORIG !
   ( destBuffAddr statusAddr bufferAddr )  ( R: len dirFlag )
   2R@ SWAP 0<> 
   IF ( destBuffAddr statusAddr bufferAddr dirFlag )  ( R: len dirFlag )
      IF 1 ELSE 0 THEN 2R@ DROP
( destBuffAddr statusAddr bufferAddr dirCtrlr len )  ( R: len dirFlag )
      3 USBTRBTYPE !  
      USBDATASTAGE                 ( destBuffAddr ) ( R: len dirFlag )
      USBSLOTID @ USBSACUREPRINGPTR 
      USBSLOTID @ USBRINGCTRLEP  
      USBSTATUSADDR @ 07D0 USBWAITFORRESPONSE
      INVERT IF DROP 2R> 2DROP FALSE EXIT THEN 
   ELSE 2DROP NIP 
   THEN
   2R@ USBGSTSTAGEDIR                ( destBuffAddr dirCtrlr ) ( R: len dirFlag )
   USBSTATUSADDR @ USBSTATUSSTAGE   ( destBuffAddr ) ( R: len dirFlag )
   USBSLOTID @ USBSACUREPRINGPTR 
   USBSLOTID @ USBRINGCTRLEP  
   USBSTATUSADDR @ 07D0 USBWAITFORRESPONSE
   INVERT IF DROP 2R> 2DROP FALSE EXIT THEN 
   2R> IF DUP 0<> 
         IF USBDTBUFFORIG @ ROT ROT CMOVE ELSE 2DROP THEN 
       ELSE 2DROP 
       THEN TRUE ;

: USBGDEVDESC  ( -- flag )
   DEVDESCBUFF TRUE REQDEVDESCPACKET 012 USBCTRLIO 
   DUP INVERT IF CR ." Control transfer failed (DevDescAll)" THEN ;

VARIABLE USBLANGID

: USBPRVENDORSTR  ( -- )
  USBBUFF DUP C@ 2- 1 RSHIFT 0 DO 2+ DUP C@ EMIT LOOP DROP ; 

: USBSALANGID  ( -- )
   USBBUFF 2+ W@ USBLANGID ! ;

: USBGMANUFI  ( -- n )
   DEVDESCBUFF 0E + C@ ;

: USBGLANGIDS?  ( -- flag )
   0 REQSTRLANGSPACKET 2 + C!
   0 REQSTRLANGSPACKET 4 + C!
   USBBUFF TRUE REQSTRLANGSPACKET 012 USBCTRLIO ;

: USBGMANUF?  ( -- flag )
     USBLANGID @ REQSTRLANGSPACKET 4 + C! 
     DEVDESCBUFF 0E + C@ REQSTRLANGSPACKET 2 + C! 
     USBBUFF TRUE REQSTRLANGSPACKET 040 USBCTRLIO ; 

: USBGPRODI  ( -- n )
   DEVDESCBUFF 0F + C@ ;

: USBGPROD?  ( -- flag )
   USBLANGID @ REQSTRLANGSPACKET 4 + C! 
   DEVDESCBUFF 0F + C@ REQSTRLANGSPACKET 2 + C! 
   USBBUFF TRUE REQSTRLANGSPACKET 64 USBCTRLIO ; 

: USBPRNONE  ( -- )
  ." None" ;

: USBPRPORTDEVADDR  ( -- )
  ."  (" USBPORT @ USBPRNSP 02C EMIT SPACE 
  USBSLOTCTXBUFF 02E + @ USBPRNSP 029 EMIT CR ;

: USBGSTRDESC  ( -- flag )
   USBGLANGIDS? INVERT 
   IF CR ." Control transfer failed (LangIDs)" FALSE EXIT THEN 
   USBSALANGID USBGMANUFI 0<>
   IF 
     USBGMANUF? INVERT 
     IF CR ." Control transfer failed (Manufacturer)" FALSE EXIT THEN 
     USBPRVENDORSTR
   ELSE USBPRNONE 
   THEN
   ."  - "
   USBGPRODI 0=
   IF USBPRNONE CR FALSE EXIT THEN 
   USBGPROD? INVERT IF CR ." Control transfer failed (Product)" FALSE EXIT THEN 
   USBPRVENDORSTR USBPRPORTDEVADDR TRUE ;

: USBPRDEVDESC   ( -- )   ( or with DUMP !?)
   CR ." DevDesc:" CR DEVDESCBUFF 012 0 DO DUP C@ DIGS2 SPACE 1+ LOOP DROP CR ;

: USBGDESCRIPTORS   ( port -- ) 
   DUP USBPORT ! USBCPORTST USBCLDEVDESC USBGSPEED USBSPEED !
   0 USBTRBSETSTYPE 9 USBTRBSETTYPE OR 0 0 0 USBTRBBUFF USBSTRB
   TRUE USBTRBBUFF USBSENDCMD IF DROP EXIT THEN 
   USBTRBBUFF 0C + @ USBTRBGETSLOT DUP 
   USBSLOTID ! 0= IF DROP EXIT THEN 
   USBSPEED @ USBGMPS USBMPS ! 
   USBINITSLOT 0 USBSAHEAPPTR USBSETADDRESS USBRHEAPPTR INVERT IF EXIT THEN 
   USBGDEVDESC INVERT IF EXIT THEN ( USBPRDEVDESC) USBGSTRDESC DROP ;

: USBSCANUSB3PORTS   ( -- )
   USBNDP @ 0 
   DO I USBISUSB3PORT I USBISACTIVE AND 
      IF I USBRESETPORT IF I USBGDESCRIPTORS THEN THEN
   LOOP ;

: USBSCANUSB2PORTS   ( -- )
   USBNDP @ 0 
   DO I USBISUSB2PORT I USBISACTIVE AND 
      IF I USBRESETPORT IF I USBGDESCRIPTORS THEN THEN
   LOOP ;

: USBPROCESS  ( b d f -- flag )
   3DUP USBEBUSMASTER USBPICL 
   3DUP USBGBASE USBBASE4BITS @ 1 AND 0<> 
   IF 3DROP FALSE ." USB not memory mapped IO" CR EXIT THEN
   USBBASE4BITS @ 4 = 
   IF 3DUP USBGUP32BITS 0<> 
     IF 3DROP FALSE ." Base0 is 64-bits (32bit OS)" CR EXIT THEN 
   THEN
   3DUP USBFLADJ USBGVER? 
   IF 3DROP FALSE ." USB version < 0x95" CR EXIT THEN 
   USBPANTHERPOINT USBCBASEOFF USBRESETCTRL? 
   IF FALSE ." Resetting the controller failed (TO)" CR EXIT THEN
   USBCEXTCAPSREGS USBSTOPLEGACY INVERT 
   IF FALSE ." BIOS did not release Legacy support" CR EXIT THEN 
   USBDOPORTS USBGPAGESIZE USBGMAXSLOTS USBALDCBAAPSTART 
   USBSOPSUSBDCBAAP USBALSCRATCHPAD USBCRCMDRING 
   USBINITUSBCRCR USBINITUSBCFG USBINITUSBDNCRTL 
   USBINITITERRUPTERS USBCLSTATUS USBCLCUREPRINGPTRARR 
   USBSTARTSCHEDULE 100 SLEEP USBSCANUSB3PORTS USBSCANUSB2PORTS TRUE ;

VARIABLE USBBUS

: PCIDETUSB  ( -- b d f TRUE )   ( -- FALSE )
   FALSE 0100 0 DO I USBBUS ! 020 0 DO 8 0 DO USBBUS @ J I 0 PCICFGRDW 0FFFF <> 
       IF USBBUS @ J I 0B PCICFGRDB 0C = IF USBBUS @ J I 0A PCICFGRDB 3 = 
       IF USBBUS @ J I 9 PCICFGRDB 030 = IF DROP USBBUS @ J I TRUE THEN THEN THEN THEN 
   LOOP LOOP LOOP ;

VARIABLE USBCSWADDR 
: USBGCLEAREDCSWADDR  ( -- addr )
   USBCSWADDR @ DUP 0D ERASE ;

VARIABLE USBDEVADDR 
VARIABLE USBSLOTADDR 
VARIABLE USBENUMDONE 

: USBENUM  ( -- flag )
   PCIDETUSB 
   IF USBHEAPINIT USBCURHEAPPTR !
      -1 USBDEVADDR ! 0FF USBINITEDMSD !
      4 010 010 USBALHEAP USBSTATUSADDR !
      0D 1 0 USBALHEAP USBCSWADDR !
      CR ." Found XHCI controller " >R >R DUP DIGS2 ." :" R> DUP DIGS2 
      ." :" R> DUP DIGS2 CR ." String (Port, DeviceAddress)" CR 
      USBPROCESS DUP USBENUMDONE ! 
   ELSE FALSE
   THEN ;

: USBGDEVDATA  ( devaddr -- flag )
  USBDCBAAPSTART @ 0 
  BEGIN
    1+ >R
	8 + DUP @ 0= IF R> 3DROP FALSE EXIT THEN
    DUP @ DUP USBSLOTADDR !
    USBSLOTCTXBUFF USBREADFROMSLOT 
    OVER USBSLOTCTXBUFF 02E + @ = R> SWAP 
  UNTIL
 ( devaddr dcbaap id )
  >R 2DROP R>
  USBSLOTCTXBUFF 02A + @ 2 =
  IF 
    USBSLOTID !
    USBSLOTCTXBUFF 6 + @ USBGMPS USBMPS ! TRUE
  ELSE DROP FALSE 
  THEN ;

: USBGBOSDESC  ( -- flag )
   USBBUFF TRUE REQBOSPACKET 016 USBCTRLIO 
   DUP INVERT IF CR ." Control transfer failed (BOS)" THEN ;

: USBPRBOSDESC   ( -- )   ( or with DUMP !?)
   CR ." BOSDesc:" CR USBBUFF 016 0 DO DUP C@ DIGS2 SPACE 1+ LOOP DROP CR ;

: USBGCONFIGDESC  ( len -- flag )
   >R USBBUFF TRUE REQCONFIGPACKET R> USBCTRLIO 
   DUP INVERT IF CR ." Control transfer failed (Config)" THEN ;

: USBPRCONFIGDESC   ( -- )   ( or with DUMP !?)
   CR ." ConfigDesc:" CR USBBUFF DUP 2+ W@ 0 DO DUP C@ DIGS2 SPACE 1+ LOOP DROP CR ;

VARIABLE USBBULKINEPT 
VARIABLE USBBULKOUTEPT 

: USBSAENDPTNUM  ( endptByte -- endptnum )
  DUP 080 AND 0<> IF 0F AND DUP USBBULKINEPT ! ELSE 0F AND DUP USBBULKOUTEPT ! THEN ;

VARIABLE USBBULKINMPS 
VARIABLE USBBULKOUTMPS 

: USBSAENDPTMPS  ( endptmps endptnum -- )
  1 = IF USBBULKINMPS ! ELSE USBBULKOUTMPS ! THEN ;

: USBSAENDPTS ( -- flag )
  USBBUFF DUP C@ + DUP 4 + C@ 1 <= 
  IF DROP FALSE CR ." Not enough endpoints" EXIT THEN
  DUP C@ + DUP 2+ C@ USBSAENDPTNUM OVER 4 + W@ SWAP USBSAENDPTMPS 
  DUP C@ + DUP 1+ C@ 030 = IF DUP C@ + THEN 
  DUP 2+ C@ USBSAENDPTNUM SWAP 4 + W@ SWAP USBSAENDPTMPS TRUE ;

: USBMSD?   ( -- flag )
  USBBUFF 4 + C@ 0<> 
  IF USBBUFF DUP C@ + 5 + C@ 8 = ELSE FALSE THEN ;

: USBGLUN  ( -- flag )
   USBBUFF TRUE REQLUNPACKET 1 USBCTRLIO 
   DUP INVERT IF CR ." Control transfer failed (LUN)" THEN ;

VARIABLE USBMAXLUN 

: USBSALUN  ( -- )
  USBBUFF C@ DUP 0FF = IF DROP 0 THEN USBMAXLUN ! ; 

: USBPRLUN  ( -- )
  CR ." MaxLun: " USBMAXLUN ? ;

( idx=0: print nothing)
( idx=1: print device-descriptor only)
( idx=2: print all the descriptors)
( If device is a Mass-Storage one [0x08], then prints MaxLun)
: USBDEVINFO  ( devaddr idx -- flag )
   USBENUMDONE @ INVERT IF 2DROP FALSE CR ." USBENUM needs to be executed first. " EXIT THEN 
   0FF USBINITEDMSD ! SWAP DUP USBDEVADDR !
   USBGDEVDATA INVERT IF 2DROP FALSE EXIT THEN 
  ( idx )
   USBSLOTID @ USBGCUREPRINGPTR 
   DUP 0<> IF CR ." Getting Device-descriptor ..." THEN 
   USBGDEVDESC INVERT IF DROP FALSE EXIT THEN 
   DUP 0<> IF USBPRDEVDESC THEN 
   USBMPS @ 0200 U>=
   IF  ( BOS)
     DUP 2 = IF CR ." Getting BOS-descriptor ..." THEN 
     USBGBOSDESC INVERT IF DROP FALSE EXIT THEN 
     DUP 2 = IF USBPRBOSDESC THEN 
   THEN   
   DUP 2 = IF CR ." Getting Configuration-descriptor ..." THEN 
   040 USBGCONFIGDESC INVERT IF DROP FALSE EXIT THEN 
   USBBUFF 2+ W@ DUP 040 U>
   IF USBGCONFIGDESC INVERT IF DROP FALSE EXIT THEN ELSE DROP THEN
   DUP 2 = IF USBPRCONFIGDESC THEN 
   USBSAENDPTS INVERT IF DROP FALSE EXIT THEN 
   USBMSD? INVERT IF DROP TRUE EXIT THEN 
   DUP 2 = IF CR ." Getting LUN ..." THEN 
   USBGLUN INVERT IF DROP FALSE EXIT THEN 
   USBSALUN 2 = IF USBPRLUN THEN TRUE ;

VARIABLE USBBULKINEPRINGPTR 
VARIABLE USBBULKINEPRINGCYCLE 
VARIABLE USBBULKOUTEPRINGPTR 
VARIABLE USBBULKOUTEPRINGCYCLE 

: USBSBULKCTX  ( slotaddr dirFlag mps -- )  
   USBTRBSPERBULKRING USBCRRING DUP >R
   USBEPCTXBUFF 022 + 0 OVER CELL+ ! ! 
   1 USBEPCTXBUFF 02A + C! 
   SWAP  
   IF 
     R> USBBULKINEPRINGPTR !
     USBEPCTXBUFF 02A + C@ USBBULKINEPRINGCYCLE !
     6 USBEPCTXBUFF 01A + ! 
   ELSE 
     R> USBBULKOUTEPRINGPTR !
     USBEPCTXBUFF 02A + C@ USBBULKOUTEPRINGCYCLE !
     2 USBEPCTXBUFF 01A + ! 
   THEN 
   USBEPCTXBUFF 011 + !
   ( slotaddr )
   0 USBEPCTXBUFF 4 + C!
   0 USBEPCTXBUFF 5 + !
   0 USBEPCTXBUFF 9 + !
   0 USBEPCTXBUFF 0D + !
   0 USBEPCTXBUFF 019 + C!
   0C00 USBEPCTXBUFF 02F + !
   3 USBEPCTXBUFF 01E + !
   0 USBEPCTXBUFF 015 + !
   0 USBEPCTXBUFF !
   USBEPCTXBUFF SWAP USBWRITETOEP ;

: USBBULKRESET  ( -- flag )
   USBBUFF FALSE REQBULKRESETPACKET 0 USBCTRLIO ; 

VARIABLE USBCURRTAG

: USBRINGBULKEP  ( n slotid -- )
   2 LSHIFT USBBASE0 @ USBDBOFF @ + + ! ;

: USBBULKIO ( statusAddr bufferAddr flagDir len -- flag )
   2>R >R DUP R> 2R> OVER 
   IF USBBULKINEPRINGPTR USBBULKINEPRINGCYCLE 
   ELSE USBBULKOUTEPRINGPTR USBBULKOUTEPRINGCYCLE THEN
   USBEPRINGCYCLE ! USBEPRINGPTR ! 
   SWAP DUP >R IF 1 ELSE 0 THEN SWAP FALSE USBCTRLTRANSFER !
   1 USBTRBTYPE ! USBDATASTAGE 
   R> ( statusAddr dir )
   IF USBBULKINEPT @ 1 = IF 3 ELSE 5 THEN 
   ELSE USBBULKOUTEPT @ 1 = IF 2 ELSE 4 THEN 
   THEN
   USBSLOTID @ USBRINGBULKEP 01388 USBWAITFORRESPONSE ;

: USBCHKCSW  ( buffAddr tag -- flag )
   OVER 4 + @ = 
   IF 0C + C@ 0= 
   ELSE DROP FALSE 
   THEN ;

VARIABLE USBDEVSIZE
VARIABLE USBSCSICAP 
VARIABLE USBSECTORSI
VARIABLE USBMAXLBAHI
VARIABLE USBMAXLBALO 

: USBSCSIREQ  ( packetAddr len -- flag )
   >R DUP 4 + @ USBCURRTAG !
   USBGCLEAREDSTATUSADDR 
  ( packetAddr statusAddr )   ( R: len )
   SWAP FALSE 01F
  ( statusAddr bufferAddr dir size )  ( R: len )
   USBBULKIO INVERT IF R> DROP FALSE CR ." Send CBW failed. " EXIT THEN 
   R@ 0<>
   IF 
     USBGCLEAREDSTATUSADDR R@
    ( statusAddr len )
     1 0 USBALHEAP SWAP OVER TRUE R@
    ( bulkArrAddr statusAddr bulkArrAddr dir len )  ( R: len )
     USBBULKIO INVERT IF R> 2DROP FALSE CR ." Get CBW failed. " EXIT THEN 
     R> USBSCSICAP @ 
     IF 
       020 <>
       IF 
         DUP @ BSWAP4 USBMAXLBALO ! 0 USBMAXLBAHI ! 
         4 + @ BSWAP4 USBSECTORSI ! 
       ELSE 
         DUP @ BSWAP4 USBMAXLBAHI ! 
         4 + DUP @ BSWAP4 USBMAXLBALO ! 
         4 + @ BSWAP4 USBSECTORSI ! 
       THEN 
     ELSE 2DROP 
     THEN  
   ELSE R> DROP
   THEN
   USBGCLEAREDSTATUSADDR 
  ( statusAddr )
   USBGCLEAREDCSWADDR DUP >R TRUE 0D
  ( statusAddr bulkArrAddr dir len )  ( R: addrCSW )
   USBBULKIO INVERT IF R> DROP FALSE CR ." Get CSW failed. " EXIT THEN 
   R> USBCURRTAG @ USBCHKCSW DUP
   INVERT IF CR ." Check CSW failed. " THEN ;

( *** For debugging ***)
( : USBPRSLOTCTXBUFF ) ( -- )
(   USBSLOTCTXBUFF )
(   DUP CR ." SlotCtxEntries:" @ . 4 + )
(   DUP CR ." SlotCtxHUB:" C@ . 1+ )
(   DUP CR ." SlotCtxMTT:" C@ . 1+ )
(   DUP CR ." SlotCtxSpeed:" @ . 4 + )
(   DUP CR ." SlotCtxRouteString:" @ . 4 + )
(   DUP CR ." SlotCtxNumPorts:" @ . 4 + )
(   DUP CR ." SlotCtxRHPortNum:" @ . 4 + )
(   DUP CR ." SlotCtxMaxExitLatOffs:" @ . 4 + )
(   DUP CR ." SlotCtxIntTargetOffs:" @ . 4 + )
(   DUP CR ." SlotCtxTTT:" @ . 4 + )
(   DUP CR ." SlotCtxPortNum:" @ . 4 + )
(   DUP CR ." SlotCtxHUBSlotID:" @ . 4 + )
(   DUP CR ." SlotCtxSlotState:" @ . 4 + )
(   CR ." SlotCtxDeviceAddress:" @ . ; )

( *** For debugging ***)
( : USBPREPCTXBUFF ) ( -- )
(   USBEPCTXBUFF )
(   DUP CR ." EPCtxInterVal:" @ . 4 + )
(   DUP CR ." EPCtxLSAs:" C@ . 1+ )
(   DUP CR ." EPCtxMaxPStreams:" @ . 4 + )
(   DUP CR ." EPCtxMult:" @ . 4 + )
(   DUP CR ." EPCtxState:" @ . 4 + )
(   DUP CR ." EPCtxMaxPacketSize:" @ . 4 + )
(   DUP CR ." EPCtxMaxBurstSize:" @ . 4 + )
(   DUP CR ." EPCtxMaxHID:" C@ . 1 + )
(   DUP CR ." EPCtxEPType:" @ . 4 + ) 
(   DUP CR ." EPCtxCErr:" @ . 4 + )
(   DUP CR ." EPCtxTRDequeuePtrLo:" @ . 4 + )
(   DUP CR ." EPCtxTRDequeuePtrHi:" @ . 4 + )
(   DUP CR ." EPCtxDCS:" C@ . 1 + )
(   DUP CR ." EPCtxMaxEsitPayload:" @ . 4 + )
(   CR ." EPCtxMaxAverageTRBLen:" @ . ; )

: USBINITMSD  ( devaddr -- lbaLo lbaHI sectorSize flag ) 
   USBDEVADDR @ <> IF 0 0 0 FALSE EXIT THEN 
   5 USBSLOTCTXBUFF !
   USBSLOTADDR @ USBCTXSIZE @ 1 * + USBEPCTXBUFF USBREADFROMEP
   USBSAHEAPPTR 
   USBCTXSIZE @ 5 LSHIFT USBCTXSIZE @ + 040 USBPAGESIZE @ USBALHEAP
   ( addrInputCtx )
   0 OVER ! 3 OVER CELL+ !
   USBSLOTCTXBUFF OVER USBCTXSIZE @ + DUP >R USBWRITETOSLOT
   USBEPCTXBUFF R> USBCTXSIZE @ 1 * + DUP >R USBWRITETOEP
   R> USBCTXSIZE @ + 
   ( addrInputCtx addrInputCtx+CtxSize+CTRLEPT*CtxSize+CtxSize )
   USBBULKOUTEPT @ 1 = 
   IF 
     OVER 4 + 027 SWAP ! 
     DUP FALSE USBBULKOUTMPS @ USBSBULKCTX 
     USBCTXSIZE @ 3 * + 
   ( addrInputCtx addrInputCtx+CtxSize+CTRLEPT*CtxSize+CtxSize+3*CtxSize )
     TRUE USBBULKINMPS @ USBSBULKCTX 
   ELSE
     USBCTXSIZE @ + 
     OVER 4 + 01B SWAP ! 
     DUP TRUE USBBULKINMPS @ USBSBULKCTX 
     USBCTXSIZE @ + 
   ( addrInputCtx addrInputCtx+CtxSize+CTRLEPT*CtxSize+CtxSize+2*CtxSize )
     FALSE USBBULKOUTMPS @ USBSBULKCTX 
   THEN 
  ( addrInputCtx )
   >R USBSLOTID @ USBTRBSETSLOT 0C USBTRBSETTYPE OR 0 0 R> USBTRBBUFF USBSTRB 
   TRUE USBTRBBUFF USBSENDCMD 
   IF 0 0 0 FALSE CR ." Configure Endpoint failed (SendCmd). " EXIT THEN 
   USBRHEAPPTR USBTRBBUFF 8 + @ USBTRBGETCOMPCODE 1 <> 
   IF 0 0 0 FALSE CR ." Configure Endpoint failed (Code). " EXIT THEN 
   USBBUFF FALSE REQSCONFIGPACKET 0 USBCTRLIO 
   INVERT IF 0 0 0 FALSE CR ." SetConfig failed" EXIT THEN 
   USBBULKRESET INVERT IF 0 0 0 FALSE CR ." Bulk reset failed" EXIT THEN 
   064 DELAY
   FALSE USBSCSICAP !
   SCSIINQUIRYCBW 024 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." InquiryReq failed" EXIT THEN 
   SCSITESTUNITCBW 0 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." TestUnitReq failed" EXIT THEN 
   SCSISENSECBW 012 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." SenseReq failed" EXIT THEN 
   SCSITESTUNITCBW 0 USBSCSIREQ INVERT IF 0 0 0 FALSE CR ." TestUnitReq failed" EXIT THEN 
   TRUE USBSCSICAP !
   0 USBDEVSIZE !
   SCSIREADCAPACITY10CBW 8 USBSCSIREQ 
   INVERT IF 0 0 0 FALSE CR ." ReadCapacity failed" EXIT THEN
   USBMAXLBALO @ FFFFFFFF =  
   IF DROP 2DROP SCSIREADCAPACITY16CBW 020 USBSCSIREQ 
     INVERT IF 0 0 0 FALSE CR ." ReadCapacity failed" EXIT THEN
     2 USBDEVSIZE ! 
   ELSE USBMAXLBALO @ 01000000 U> IF 1 USBDEVSIZE ! THEN 
   THEN 
   USBMAXLBALO @ USBMAXLBAHI @ USBSECTORSI @
   USBDEVADDR @ USBINITEDMSD ! TRUE ;

: USBALIGNTOPAGE  ( addr -- addrAligned )
   DUP 0FFF AND 0<> IF FFFFF000 AND 01000 + THEN ;

: USBRDWRCOMMON  ( memAddr byteCntToRead flagRW cbw -- flag )
   >R 2>R USBALIGNTOPAGE 2R> R> DUP 4 + 1 OVER +! @ USBCURRTAG !
   USBGCLEAREDSTATUSADDR SWAP FALSE 01F USBBULKIO INVERT
   IF DROP 2DROP FALSE CR ." Send CBW failed. " EXIT THEN
  ( memAddr byteCntToRead flagRW )
   2>R >R USBGCLEAREDSTATUSADDR R> R> R> USBBULKIO INVERT 
   IF FALSE CR ." Get/Send data failed. " EXIT THEN
   USBGCLEAREDCSWADDR  
   USBGCLEAREDSTATUSADDR OVER TRUE 0D USBBULKIO INVERT 
   IF DROP FALSE CR ." Get CSW failed. " EXIT THEN
   USBCURRTAG @ USBCHKCSW DUP INVERT 
   IF CR ." Check CSW failed. " THEN ;

: USBRDWR10REQ  ( LBALo memAddr sectorcnt flagRW cbw -- flag )
   2>R ROT BSWAP4 R@ 011 + ! DUP BSWAP2 R@ 016 + W! 
   USBSECTORSI @ * DUP R@ 8 + ! 2R> USBRDWRCOMMON ;

: USBRDWR12REQ  ( LBALo memAddr sectorcnt flagRW cbw -- flag )
   2>R ROT BSWAP4 R@ 011 + ! DUP BSWAP4 R@ 015 + ! 
   USBSECTORSI @ * DUP R@ 8 + ! 2R> USBRDWRCOMMON ;

: USBRDWR16REQ  ( LBALo LBAHi memAddr sectorcnt flagRW cbw -- flag )
   2>R ROT BSWAP4 R@ 011 + ! ROT BSWAP4 R@ 015 + ! 
   DUP BSWAP4 R@ 019 + ! 
   USBSECTORSI @ * DUP R@ 8 + ! 2R> USBRDWRCOMMON ;

: USBRWCHK  ( lbalo lbaHi -- flag )
   USBDEVADDR @ USBINITEDMSD @ <> 
   IF 2DROP FALSE CR ." MSD not inited." 
   ELSE 
     USBMAXLBALO @ USBMAXLBAHI @ DU< 
     IF TRUE ELSE FALSE CR ." LBA too big." THEN
   THEN ;

: USBREAD  ( lbalo lbaHi memAddr sectorcnt -- flag )
   2OVER USBRWCHK 
   IF  
     USBDEVSIZE @ 
     CASE 
       0 OF >R ROT DROP TRUE SCSIREAD10CBW USBRDWR10REQ R> ENDOF 
       1 OF >R ROT DROP TRUE SCSIREAD12CBW USBRDWR12REQ R> ENDOF 
       2 OF >R          TRUE SCSIREAD16CBW USBRDWR16REQ R> ENDOF 
     ENDCASE 
   ELSE 2DROP 2DROP FALSE THEN ;

: USBWRITE  ( lbalo lbaHi memAddr sectorcnt -- flag )
   2OVER USBRWCHK 
   IF  
     USBDEVSIZE @ 
     CASE 
       0 OF >R ROT DROP FALSE SCSIWRITE10CBW USBRDWR10REQ R> ENDOF 
       1 OF >R ROT DROP FALSE SCSIWRITE12CBW USBRDWR12REQ R> ENDOF 
       2 OF >R          FALSE SCSIWRITE16CBW USBRDWR16REQ R> ENDOF 
     ENDCASE 
   ELSE 2DROP 2DROP FALSE THEN ;


