: IDE ;   ( marker for FORGET)

HEX

: KEY? KEYW DISCARD DROP ;  ( for testing)

( register-offsets [Primary bus: 0x1F0- ; for secondary: 0x170-])
0 CONSTANT HDPORTDATA
1 CONSTANT HDPORTERROR	
2 CONSTANT HDPORTSECTCNT
3 CONSTANT HDPORTSECTNUM
4 CONSTANT HDPORTCYLLOW
5 CONSTANT HDPORTCYLHIGH
6 CONSTANT HDPORTDRVHEAD
7 CONSTANT HDPORTSTATUS
7 CONSTANT HDPORTCOMMAND

( status-reg's bits)
01  CONSTANT HDSTERR
02  CONSTANT HDSTIDX
04  CONSTANT HDSTDDRC
08  CONSTANT HDSTDRQ
010 CONSTANT HDSTSRV
020 CONSTANT HDSTDF
040 CONSTANT HDSTRDY
080 CONSTANT HDSTBSY

02  CONSTANT HDDCRNIEN
04  CONSTANT HDDCRSRST
080 CONSTANT HDDCRHOB

( HD ids)
0A0 CONSTANT HDCHSMASTER    ( 0xB0 is slave; i.e. 0xA0 | slave_bit)  
0E0 CONSTANT HDLBA28MASTER	 ( 0xF0 is slave)
040 CONSTANT HDLBA48MASTER	 ( 0x50 is slave)

( HD commands)
0   CONSTANT HDCMDNOP
020 CONSTANT HDCMDREAD
024 CONSTANT HDCMDREADEXT       ( LBA48)
030 CONSTANT HDCMDWRITE
034 CONSTANT HDCMDWRITEEXT      ( LBA48)
040 CONSTANT HDCMDREADVRFY      ( sectors)
090 CONSTANT HDCMDDIAG          ( execute device diagnostics)
0E0 CONSTANT HDCMDSTDBYIMM
0E1 CONSTANT HDCMDIDLEIMM
0E2 CONSTANT HDCMDSTDBY
0E3 CONSTANT HDCMDIDLE
0E5 CONSTANT HDCMDCHKPWRMODE
0E6 CONSTANT HDCMDSLEEP
0E7 CONSTANT HDCMDFLUSHCACHE
0EA CONSTANT HDCMDFLUSHCACHEEXT	
0EC CONSTANT HDCMDIDENTIFY

( cmd results)
0 CONSTANT HDOK
1 CONSTANT HDNODRIVE
2 CONSTANT HDERR
3 CONSTANT HDLOCKED
4 CONSTANT HDTIMEOUT

CREATE HDPORTS 01F0 W, 0 W, 01F0 W, 1 W, 0170 W, 0 W, 0170 W, 0 W,

VARIABLE HDPORTBASE
VARIABLE HDPORTCTRL
VARIABLE HDSLAVEBIT
VARIABLE HDDETECTED

VARIABLE HDATA
VARIABLE HDLBA
VARIABLE HDLBA48
VARIABLE HDMAXLBA28
2VARIABLE HD2MAXLBA48
VARIABLE HDLOGSECTORSI
VARIABLE HDLOGPERPHYS
2VARIABLE HD2MAXLBA
2VARIABLE HD2CAP
VARIABLE HDLIMIT    ( max sectorcnt per read/write)
VARIABLE HDLIMITSH  ( 2 to the power of this value will be HDLIMIT)
VARIABLE HDWRFL     ( read/write flag)

014D000 CONSTANT HDIDARR  ( Pointer to 512byte memory for IDENTIFY)

( Nibble-swap)
: NSWAP  ( n1 -- n2 )
   DUP 4 RSHIFT SWAP 4 LSHIFT OR ;

: HDSELDRV  ( portbase slavebit -- )
   4 LSHIFT HDCHSMASTER OR SWAP HDPORTDRVHEAD + OUTB ;

: HDSZEROS  ( portbase -- )
   >R 0 R@ HDPORTSECTCNT + OUTB 
   0 R@ HDPORTSECTNUM + OUTB 
   0 R@ HDPORTCYLLOW + OUTB 
   0 R> HDPORTCYLHIGH + OUTB ;

( Send Identify)
: HDSDID  ( portbase -- )
   HDCMDIDENTIFY SWAP HDPORTCOMMAND + OUTB ;

: HDCHKDRV  ( portbase -- flag )
   DUP HDPORTCYLLOW + INB DUP DUP 0= SWAP 03C = OR 
( portbase val flag )
   IF NSWAP SWAP HDPORTCYLHIGH + INB = ELSE 2DROP FALSE THEN ;

: HDPOLL  ( portbase -- flag )
   HDPORTSTATUS + 0
   BEGIN DROP DUP INB DUP HDSTBSY AND 0= UNTIL  ( TO!?)
   NIP HDSTERR HDSTDF OR AND 0= ;

: HDRDID  ( portbase -- )
   HDPORTDATA + HDIDARR 0100 0 DO
     OVER INW ( portAddr addr val ) OVER W! W+
   LOOP 2DROP ;

( Get ATA)
: HDGATA  ( -- )
   HDIDARR W@ 08000 AND 0= HDATA ! ;

: HDGLBA  ( -- )
   HDIDARR 062 + W@ 0200 AND 0<> HDLBA ! ;

: HDGLBA48  ( -- )
   HDIDARR 0A6 + W@ 0400 AND 0<> HDLBA48 ! ;

: HDGMAXLBA28  ( -- )
   HDIDARR 078 + @ HDMAXLBA28 ! ;

: HDGMAXLBA48  ( -- )
   HDIDARR 0C8 + DUP @ SWAP 4 + @ HD2MAXLBA48 2! ;

: HDGSECTSIZE  ( -- )
   HDIDARR 0D4 + W@ DUP 0C000 AND 04000 = 
   IF DUP DUP 02000 AND 0<> IF 0F AND HDLOGPERPHYS ! ELSE DROP THEN 
     01000 AND 0<> 
     IF HDIDARR 0EA + @ HDLOGSECTORSI ! ELSE 0200 HDLOGSECTORSI ! THEN 
   ELSE DROP 0200 HDLOGSECTORSI !
   THEN ;

( Compute divisor for capacity)
: HDCCAPDIV  ( -- n )
   HDLOGSECTORSI @ 
   CASE 
     0200  OF >R 0800 R> ENDOF 
     0400  OF >R 0400 R> ENDOF 
     0800  OF >R 0200 R> ENDOF 
     01000 OF >R 0100 R> ENDOF 
   ENDCASE ;

( Compute limits)
: HDCLIMS  ( divisor -- )
   HDLBA48 @ 
   IF 010000 HDLIMIT ! 010 HDLIMITSH ! HD2MAXLBA48 2@ 
   ELSE 0100 HDLIMIT ! 08 HDLIMITSH ! HDMAXLBA28 @ S>D 
   THEN 
   2DUP HD2MAXLBA 2! ROT 1 SWAP M*/ HD2CAP 2! ;

: HDIDENTIFY  ( portbase slavebit -- res )
   OVER >R HDSELDRV R@ HDSZEROS R@ HDSDID 
   R@ HDCHKDRV INVERT IF R> DROP HDNODRIVE EXIT THEN 
   R@ HDPOLL INVERT IF R> DROP HDERR EXIT THEN 
   R> HDRDID HDGATA HDGLBA HDGLBA48 HDGMAXLBA28 HDGMAXLBA48  
   HDGSECTSIZE HDCCAPDIV HDCLIMS HDOK ;

: HDINFO  ( -- )
   HDDETECTED @ INVERT IF EXIT THEN 
   CR ." Serial number: " HDIDARR 014 + 
   0A 0 DO DUP W@ DUP 08 RSHIFT EMIT 0FF AND EMIT W+ LOOP DROP 
   CR ." Firmware version: " HDIDARR 02E + 
   04 0 DO DUP W@ DUP 08 RSHIFT EMIT 0FF AND EMIT W+ LOOP DROP 
   CR ." Model number: " HDIDARR 036 + 
   014 0 DO DUP W@ DUP 08 RSHIFT EMIT 0FF AND EMIT W+ LOOP DROP 
   CR ." Supported: " HDLBA @ IF ." LBA " THEN 
   HDLBA48 @ IF ." LBA48 " THEN 
   HDIDARR 062 + W@ 0100 AND 0<> IF ." DMA " THEN 
   CR ." MaxLBA28: " HDMAXLBA28 ?
   HDLBA48 @ IF CR ." MaxLBA48: " HD2MAXLBA48 2@ D. THEN 
(   CR ." C H S: ")
(   HDIDARR 2+ W@ . HDIDARR 06 + W@ . HDIDARR 0C + W@ .)
   CR ." Max number of logical sectors per r/w multiple cmds: "
   HDIDARR 05E + W@ 0FE AND 1 RSHIFT .
   HDLOGPERPHYS @ 0<> IF 
   CR ." Logical sectors per physical sector: " HDLOGPERPHYS ? THEN
   CR ." Logical sectorsize: " HDLOGSECTORSI ? 
   CR ." Capacity: " HD2CAP 2@ D. ." MiB"
   CR HDPORTBASE @ 01F0 = 
   IF ." Primary bus, " ELSE ." Secondary bus, " THEN
   HDSLAVEBIT @ 0= IF ." Master" ELSE ." Slave" THEN CR ;

( We can execute it, if after boot "HD: IDE" is shown)
( The main harddisk-detection function)
( Detects first available harddisk on primary and secondary bus [master or slave])
( Sets variables [portbase, slavebit] accordingly)
( Executes IDENTIFY cmd)
: HDDET  ( -- flag )
   FALSE HDDETECTED !
   HDPORTS 4 0 
   DO 
     DUP W@ OVER W+ W@ HDIDENTIFY HDOK = HDATA @ AND HDLBA @ AND
     IF DUP W@ HDPORTBASE ! DUP W+ W@ HDSLAVEBIT ! TRUE HDDETECTED ! LEAVE THEN 
     CELL+ 
   LOOP DROP HDDETECTED @ ;

( Common for LBA28 Read/Write)
: HDCOM28  ( sectcnt lba -- )
   HDLBA28MASTER HDSLAVEBIT @ 04 LSHIFT OR OVER 24 RSHIFT 0F AND OR  
   HDPORTBASE @ HDPORTDRVHEAD + OUTB
   0 HDPORTBASE @ HDPORTERROR + OUTB
   SWAP 0FF AND HDPORTBASE @ HDPORTSECTCNT + OUTB
   DUP 0FF AND HDPORTBASE @ HDPORTSECTNUM + OUTB
   DUP 08 RSHIFT AND HDPORTBASE @ HDPORTCYLLOW + OUTB
   010 RSHIFT AND HDPORTBASE @ HDPORTCYLHIGH + OUTB ;

( Common for LBA48 Read/Write)
: HDCOM48  ( sectcnt lbalo lbahi -- )
   HDLBA48MASTER HDSLAVEBIT @ 04 LSHIFT OR 
   HDPORTBASE @ HDPORTDRVHEAD + OUTB
   ROT DUP >R 08 RSHIFT 0FF AND HDPORTBASE @ HDPORTSECTCNT + OUTB
   OVER 018 RSHIFT 0FF AND HDPORTBASE @ HDPORTSECTNUM + OUTB
   DUP 08 RSHIFT 0FF AND HDPORTBASE @ HDPORTCYLLOW + OUTB
   0FF AND HDPORTBASE @ HDPORTCYLHIGH + OUTB
   R> 0FF AND HDPORTBASE @ HDPORTSECTCNT + OUTB
   DUP 0FF AND HDPORTBASE @ HDPORTSECTNUM + OUTB
   DUP 08 RSHIFT 0FF AND HDPORTBASE @ HDPORTCYLLOW + OUTB
   010 RSHIFT 0FF AND HDPORTBASE @ HDPORTCYLHIGH + OUTB ;

: WAITBSY  ( -- )   ( TO!? "1 SLEEP" in loop)
   HDPORTBASE @ HDPORTSTATUS + BEGIN DUP INB HDSTBSY AND 0= UNTIL DROP ;

: HDSENDCMD  ( cmd -- flag )
   HDPORTBASE @ HDPORTCOMMAND + SWAP OVER OUTB
   04 0 DO 
     DUP INB DUP HDSTBSY AND 0= 
     IF HDSTDRQ AND 0<> IF DROP TRUE UNLOOP EXIT THEN THEN 
   LOOP 
   DROP WAITBSY INB HDSTERR HDSTDF OR AND 0= ;

: HDRDSECT  ( memaddr port -- )
   HDLOGSECTORSI @ 1 RSHIFT 0 DO 2DUP INSW SWAP W+ SWAP LOOP 2DROP ;

: HDWRSECT ( memaddr port -- )
   HDLOGSECTORSI @ 1 RSHIFT 0 DO 2DUP OUTSW ( delay!?) SWAP W+ SWAP LOOP 2DROP ;

: HDDELAY  ( -- )
   HDPORTBASE @ HDPORTSTATUS + DUP 2DUP INB DROP INB DROP INB DROP INB DROP ;

: HDFLUSH  ( -- )
   HDCMDFLUSHCACHEEXT HDPORTBASE @ HDPORTCOMMAND + OUTB WAITBSY ;

: HDGCMD ( -- )
   HDWRFL @ IF HDCMDWRITE ELSE HDCMDREAD THEN HDLBA48 @ IF 04 OR THEN ;

: HDRW  ( memaddr sectcnt lbalo lbahi -- flag )
   2>R DUP 2R> HDLBA48 @ IF HDCOM48 ELSE DROP HDCOM28 THEN 
( memaddr sectcnt )
   HDGCMD HDSENDCMD INVERT IF 2DROP FALSE EXIT THEN  ( abort" !?)
   HDPORTBASE @ HDPORTDATA + SWAP 0
( memaddr port sectcnt 0 )
   DO
     2DUP HDWRFL @ IF HDWRSECT ELSE HDRDSECT THEN 
     SWAP HDLOGSECTORSI @ + SWAP 
( memaddr+ port )
     HDDELAY PAUSE WAITBSY HDPORTBASE @ HDPORTSTATUS + 
     INB HDSTERR HDSTDF OR AND 0<> IF 2DROP FALSE UNLOOP EXIT THEN 
   LOOP 
   2DROP HDPORTBASE @ HDPORTSTATUS + INB HDSTERR HDSTDF OR AND 0= 
   DUP IF HDWRFL @ IF HDFLUSH THEN THEN ;

: HDCHKLBA  ( lbalo lbahi -- flag )
   HD2MAXLBA 2@ DU< ;

VARIABLE HDSECTCNTQUOT
VARIABLE HDSECTCNTREM

: HDRWCOM  ( memaddr sectcnt lbalo lbahi -- flag )
   ROT DUP 0= IF 2DROP 2DROP TRUE EXIT THEN 
   HDLIMIT @ /MOD HDSECTCNTQUOT ! HDSECTCNTREM !
  ( memaddr lbalo lbahi )
   HDSECTCNTQUOT @ 0<> 
   IF 
     0 ROT ROT HDSECTCNTQUOT @ 0 
    ( memaddr 0 lbalo lbahi seccntfull 0 )
     DO 
       2OVER 2OVER HDRW INVERT IF 2DROP 2DROP FALSE UNLOOP EXIT THEN 
      ( inc memaddr:)
       2SWAP SWAP HDLOGSECTORSI @ HDLIMITSH @ LSHIFT + SWAP 2SWAP 
      ( inc LBA:)
       HDLIMIT @ M+ 
     LOOP
     ROT DROP 
   THEN
   HDSECTCNTREM @ ROT ROT HDRW ;

: HDREAD  ( memaddr sectcnt lbalo lbahi -- flag )
   HDDETECTED @ INVERT IF 2DROP 2DROP FALSE EXIT THEN 
   2DUP HDCHKLBA 
   IF FALSE HDWRFL ! HDRWCOM 
   ELSE 2DROP 2DROP FALSE 
   THEN ;

: HDWRITE  ( memaddr sectcnt lbalo lbahi -- flag )
   HDDETECTED @ INVERT IF 2DROP 2DROP FALSE EXIT THEN 
   2DUP HDCHKLBA 
   IF TRUE HDWRFL ! HDRWCOM 
   ELSE 2DROP 2DROP FALSE 
   THEN ;


