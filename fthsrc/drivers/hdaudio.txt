: HDAUDIO ;   ( marker for FORGET)

HEX

0100000 CONSTANT AUCORBBUFF
0101000 CONSTANT AURIRBBUFF
0102000 CONSTANT AUDPLBUFF
0103000 CONSTANT AUBDLBUFF      ( BDL-Entries)
4 CONSTANT AUBDLENTRYCNT        ( LVI is 3)

0105000 CONSTANT AUBUFFADDR	    ( from this the four 010000 buffers)
 010000 CONSTANT AUBUFFLEN		( BDL-entries must be 128-byte aligned!! this way, the DMA engine is looping)

VARIABLE AUINITED
VARIABLE AUCODECSMASK
VARIABLE AUCODECID
VARIABLE AUCODECDEVID
VARIABLE AUCODECREVID
VARIABLE AUCODECFGNUM
VARIABLE AUAFGID
VARIABLE AU64OK
VARIABLE AUINPCNT
VARIABLE AUOUTPBASE
VARIABLE AUCORBSI
VARIABLE AURIRBSI
VARIABLE AURWP
VARIABLE AUMUTEGAIN
VARIABLE AUAFGSRTWIDID 
VARIABLE AUAFGWIDCNT 
VARIABLE AUWIDCAPS 

( the data of the widgets)
0  CONSTANT AUWIDCAPSIDX
1  CONSTANT AUSUPPSTRMFMTIDX
2  CONSTANT AUSUPPPCMSIZEIDX
3  CONSTANT AUPINCAPSIDX
4  CONSTANT AUINPAMPCAPSIDX
5  CONSTANT AUOUTPAMPCAPSIDX
6  CONSTANT AUCONNLISTLENIDX
7  CONSTANT AUVOLKNOBCAPSIDX
8  CONSTANT AUCONFIGDEFIDX
9  CONSTANT AUCONNLSTENTCTRLIDX
0A CONSTANT AUCONNLSTENTCTRL2IDX
0B CONSTANT AUWIDDATACNT 
CREATE AUWIDVERBS 0F00 W, 0F00 W, 0F00 W, 0F00 W, 0F00 W, 0F00 W, 0F00 W, 0F00 W, 
                  0F1C W, 0F02 W, 0F02 W,  
CREATE AUWIDPARAMS 9 C, 0B C, 0A C, 0C C, 0D C, 012 C, 0E C, 013 C, 0 C, 0 C, 4 C, 
080 CONSTANT AUMAXWIDCNT
CREATE AUWIDDATA AUWIDDATACNT AUMAXWIDCNT * CELLS ALLOT 
AUWIDDATA AUWIDDATACNT AUMAXWIDCNT * CELLS ERASE

CREATE AUTREEOUTPATH AUMAXWIDCNT ALLOT 
VARIABLE AUTREEOUTDEPTH
CREATE AUTREEHPPATH AUMAXWIDCNT ALLOT 
VARIABLE AUTREEHPDEPTH
CREATE AUTREEPATH AUMAXWIDCNT ALLOT 
VARIABLE AUTREEDEPTH

( Nid indices array; e.g. In case of Nid 2A, at 2A there is 2 to start the search from in 2A's connlist.)
( We also use this array to check if a node has already been visited or not)
CREATE AUNIDIDXS AUMAXWIDCNT ALLOT 

VARIABLE AUAFGSUPPSTREAMFMT 
VARIABLE AUAFGSUPPPCMFMT 

VARIABLE AUFMT
VARIABLE AUDATACOPIED 
VARIABLE AUPCMPARTMAX
VARIABLE AUPCMPART
VARIABLE AUPCMADDR
VARIABLE AUPCMLEN
VARIABLE AUBUFFNUM
VARIABLE AUPAUSED 

VARIABLE AUWIDCONNLISTLEN 
VARIABLE AUCONNLISTENTRIES 1 CELLS ALLOT 

VARIABLE AUPLAYFMT
VARIABLE AUPLAYRATE

03F CONSTANT AUDEFGAIN

: KEY?  ( -- )
   KEYW DISCARD DROP ;

( Stop Ring)
: AUSTRB  ( regoffs -- )
   AUBAR + DUP C@ DUP 2 AND 0<> IF 0FD AND SWAP C! ELSE 2DROP THEN ;

( Check Ring, stopped?)
: AURB  ( regoffs -- flag )
   AUBAR + FALSE SWAP 0A 0 DO DUP C@ 2 AND 0= IF NIP TRUE SWAP LEAVE THEN 1 DELAY LOOP DROP 
   DUP INVERT IF CR ." Error: reset RB failed." THEN ;

( Reset controller)
: AURESCTR  ( -- flag )
   AUBAR 8 + DUP @ 1 INVERT AND OVER !
   FALSE SWAP 0A 0 DO DUP @ 1 AND 0= IF NIP TRUE SWAP LEAVE THEN 1 DELAY LOOP DROP 
   DUP INVERT IF CR ." Error: reset controller failed." THEN ;

( Leave reset-state)
: AULVRES  ( -- flag )
   AUBAR 8 + DUP @ 1 OR OVER !
   FALSE SWAP 0A 0 DO DUP @ 1 AND 0<> IF NIP TRUE SWAP LEAVE THEN 1 DELAY LOOP DROP 
   DUP INVERT IF CR ." Error: leaving controller-reset-state failed." THEN ;

: AUSMASK  ( -- )
   AUBAR 0E + W@ 07FFF AND AUCODECSMASK ! ;

: AURESET  ( -- flag )
   04C AUSTRB 05C AUSTRB 
   04C AURB INVERT IF FALSE EXIT THEN 05C AURB INVERT IF FALSE EXIT THEN
   AURESCTR INVERT IF FALSE EXIT THEN 
   0A DELAY AULVRES DUP IF 0A DELAY AUSMASK THEN ;

: AUSA64OK  ( -- )
   AUBAR W@ 1 AND 0<> AU64OK ! ;

: AUOUTP  ( -- flag )
   AUBAR W@ 0F 0C LSHIFT AND 0<> DUP INVERT  
   IF CR ." Error: output-streams not supported by HW!" THEN ;

: AUGINPCNT  ( -- )
   AUBAR W@ 0F 8 LSHIFT AND 8 RSHIFT DUP AUINPCNT ! 
   5 LSHIFT 080 + AUOUTPBASE ! ; 

: AURBSI  ( regoffs -- flag )
   AUBAR + C@ 070 AND 0<> DUP INVERT  
   IF CR ." Error: RB size-cap is empty!" THEN ;

: AUGRBSI  ( regoffs -- n )
   AUBAR + DUP C@ DUP 040 AND 0<>
   IF 2 OR 0FF ELSE DUP 020 AND 0<> IF 1 OR 0F ELSE 1 THEN THEN 
   SWAP 3 AND ROT C! ; 

: AURESCORBRP  ( -- flag )
  AUBAR 04A + DUP DUP W@ 08000 OR SWAP W! 0A DELAY W@ 08000 AND 0<>
  IF AUBAR 04A + DUP W@ 07FFF AND OVER W! 1 DELAY W@ 08000 AND 0=
  ELSE FALSE THEN 
  DUP INVERT IF CR ." Error: resetting CORB-ReadPtr failed." THEN ;

: AUCLCORBWP  ( -- )
   0 AUBAR 048 + C! ;

: AUSBUFF  ( addr regoffs -- )
   AUBAR + SWAP OVER ! AU64OK @ IF 4 + 0 SWAP ! ELSE DROP THEN ;

: AUDISCMEIE  ( -- )
   AUBAR 04C + DUP C@ 0FE AND SWAP C! ;

: AUCLRIRBWP  ( -- )
   AUBAR 058 + DUP W@ 08000 OR SWAP W! 0 AURWP ! ;

: AUDISRIRBIRQ  ( -- )
   AUBAR 05C + DUP C@ 0FA AND SWAP C! ;

: AUDISIRQ  ( -- )
   AUBAR 0C + DUP W@ 08000 AND SWAP W! 0 AUBAR 020 + ! ;

: AUCLSTATUS  ( -- )
  ( CORB)
   AUBAR 04D + DUP C@ 1 OR SWAP C! 
  ( RIRB)
   AUBAR 05D + DUP C@ 5 OR SWAP C! 
  ( streams)
   AUBAR AUOUTPBASE @ + 3 + DUP C@ 01C OR SWAP C! ;

: AUSRTRB  ( regoffs -- )
   AUBAR + DUP C@ 2 OR SWAP C! ;

: AUCLSTREAM  ( -- )
   AUBAR AUOUTPBASE @ + DUP @ 01F INVERT AND SWAP ! ;

: AURESSTREAM0  ( -- )
   AUBAR AUOUTPBASE @ + DUP @ 1 OR SWAP ! ;

: AURESSTREAMVFY  ( -- flag )
   FALSE AUBAR AUOUTPBASE @ + 012C 0 
   DO DUP @ 1 AND 0<> IF NIP TRUE SWAP LEAVE THEN LOOP DROP ;

: AUCLRES  ( -- )
   AUBAR AUOUTPBASE @ + DUP @ 1 INVERT AND SWAP ! ;

: AUCLRES0  ( -- flag )
   FALSE AUBAR AUOUTPBASE @ + 
   012C 0 DO DUP @ 1 AND 0= IF NIP TRUE SWAP THEN LOOP DROP ;

: AURESPOSBUFF  ( -- )
   AUDPLBUFF 020 CELLS ERASE ;

: AURESSTREAM  ( -- flag )
   AUCLSTREAM AURESSTREAM0 0A DELAY
   AURESSTREAMVFY INVERT 
   IF FALSE CR ." Error: reset stream failed." EXIT THEN 
   0A DELAY AUCLRES 0A DELAY AUCLRES0 DUP 
   IF 0A DELAY AURESPOSBUFF 
   ELSE CR ." Error: reset stream failed." 
   THEN ;

( !?)
: AUGCORBSPACE  ( -- n )
   AUBAR 048 + W@ 0FF AND
   AUBAR 04A + W@ 0FF AND - DUP DUP 0> SWAP 0= OR  
   IF AUCORBSI @ SWAP - 
   ELSE NEGATE THEN ;

: AUCHCMEI  ( -- flag )  ( TRUE if error)
  AUBAR 04D + C@ 1 AND 1 = ;

: AUCHRIRBOIS  ( -- flag )  ( TRUE if error)
  AUBAR 05D + C@ 4 AND 2 RSHIFT 1 = ;

: AUMKCMD  ( nid verb param cad i -- cmd )
   2>R 2>R 014 LSHIFT R> OR R> 8 LSHIFT OR R> 01B LSHIFT OR R> 01C LSHIFT OR ;

: AUWRCMD  ( cmd -- )
   AUBAR 048 + SWAP OVER W@ 00FF AND DUP AUCORBSI @ <> IF 1+ ELSE DROP 0 THEN 
  ( reg cmd idx )
   SWAP OVER 
  ( reg idx cmd idx )
   CELLS AUCORBBUFF + ! 
  ( reg idx )
   OVER W!
   AUBAR 04A + 
  ( regWP regRP )
   BEGIN 2DUP W@ SWAP W@ = UNTIL 2DROP ;

: AURDRESP  ( -- resp respext )
   AURWP @ AUBAR 058 + 
   BEGIN 2DUP W@ 0FF AND <> UNTIL DROP DUP 
   AURIRBSI @ = IF DROP 0 ELSE 1+ THEN 
   DUP AURWP ! 3 LSHIFT AURIRBBUFF + DUP @ SWAP CELL+ @ ;

( Only 4 LSBs of CodecID !?)
: AUSENDCMD  ( nid verb param -- resp respext TRUE )  ( ... -- FALSE )
   AUCODECID @ 0 AUMKCMD AUWRCMD AUCHCMEI
   IF FALSE CR ." Error: sendcmd" 
   ELSE AURDRESP TRUE 
   THEN ;

: AUBSF  ( mask -- bitidx TRUE )    ( mask -- FALSE)
   FALSE SWAP 32 0 
   DO I RSHIFT DUP 1 AND 0<> IF 2DROP I TRUE 0 LEAVE THEN LOOP DROP ;

: AUFINDAFG  ( nid -- flag )
   DUP 0FF 010 LSHIFT AND 010 RSHIFT AUAFGID !
   FALSE SWAP 0FF AND 0
   DO
     AUAFGID @ 0F00 5 AUSENDCMD INVERT IF LEAVE THEN 
     DROP 0FF AND 1 = IF DROP TRUE LEAVE THEN 
     1 AUAFGID +!
   LOOP 
   DUP INVERT IF CR ." Error: AFG not found." THEN ;

: AUGWIDSNUM  ( -- flag )
   AUAFGID @ 0F00 4 AUSENDCMD  
   IF
     DROP DUP 0FF 010 LSHIFT AND 010 RSHIFT AUAFGSRTWIDID !
     0FF AND AUAFGWIDCNT ! TRUE
   ELSE FALSE CR ." Error: getting AFG widget-num, widget-cnt."
   THEN ;

: AUGWIDDATA  ( nid -- flag )
    TRUE SWAP AUWIDDATACNT 0 
    DO 
      AUWIDVERBS I CELLS 1 RSHIFT + W@ 0F02 = 
      IF AUWIDPARAMS I + C@ 0<>
        IF AUWIDCONNLISTLEN @ 07F AND 4 U<= IF LEAVE THEN 
        ELSE AUWIDCAPS @ 1 8 LSHIFT AND 0= IF LEAVE THEN 
        THEN 
      THEN 
      DUP AUWIDVERBS I CELLS 1 RSHIFT + W@ AUWIDPARAMS I + C@  
      AUSENDCMD INVERT IF NIP FALSE SWAP LEAVE THEN 
( flag nid res resext )
      DROP OVER >R DUP R> AUAFGSRTWIDID @ - AUWIDDATACNT * CELLS AUWIDDATA I CELLS + + ! 
( flag nid res )
      DUP AUWIDPARAMS I + C@ 9 = IF AUWIDCAPS ! ELSE DROP THEN  
( flag nid res )
      AUWIDPARAMS I + C@ 0E = IF AUWIDCONNLISTLEN ! ELSE DROP THEN  
    LOOP DROP ;

: AUGCODECSDATA  ( -- flag )
  0 BEGIN DROP AUGCORBSPACE DUP 0<> UNTIL DROP
 ( vendorId)
  AUCODECSMASK @ AUBSF INVERT 
  IF CR ." Error: No bit set in codecs-mask." FALSE EXIT THEN 
  AUCODECID !
  0 0F00 0 AUSENDCMD INVERT IF FALSE EXIT THEN 
  DROP AUCODECDEVID ! 
 ( revisionId)
  0 0F00 2 AUSENDCMD INVERT IF FALSE EXIT THEN 
  DROP AUCODECREVID ! 
 ( numberOfFGs)
  0 0F00 4 AUSENDCMD INVERT IF FALSE EXIT THEN 
  DROP DUP AUCODECFGNUM ! 
 ( find AFG)
  AUFINDAFG INVERT IF FALSE EXIT THEN 
 ( numberOfWidgets)
  AUGWIDSNUM INVERT IF FALSE EXIT THEN 
 ( getParamsOfWidgets)
  TRUE AUAFGSRTWIDID @ DUP AUAFGWIDCNT @ + SWAP
  DO I AUGWIDDATA INVERT IF DROP FALSE LEAVE THEN LOOP ;

: AUGAFGSUPPSTREAMFMT  ( -- flag )
   AUAFGID @ 0F00 0B AUSENDCMD 
   IF DROP 07 AND AUAFGSUPPSTREAMFMT ! TRUE
   ELSE FALSE CR ." Error: getting AFG supported stream format failed."
   THEN ;

: AUGAFGSUPPFMT  ( -- flag )
   AUAFGID @ 0F00 0A AUSENDCMD 
   IF DROP 01F0FFF AND AUAFGSUPPPCMFMT ! TRUE 
   ELSE FALSE CR ." Error: getting AFG supported pcm format failed."
   THEN ;

: AUGSUPPSTREAMFMT  ( -- fmt )
   AUINITED @ IF AUAFGSUPPSTREAMFMT @ ELSE 0 THEN ;

: AUGSUPPPCMFMT  ( -- fmt )
   AUINITED @ IF AUAFGSUPPPCMFMT @ ELSE 0 THEN ;

( **AUSENDCMD when set-cmd: 2 cells are returned**!?)
: AUSCONVSTREAM  ( nidDAC -- flag )
   DUP 0706 010 AUSENDCMD INVERT IF DROP FALSE EXIT THEN 
   2DROP 1 DELAY 
   0200 AUFMT @ AUSENDCMD IF 2DROP TRUE ELSE FALSE THEN ;

: AUCLIRQ  ( -- )
   AUBAR AUOUTPBASE @ + 3 + DUP C@ 03C AND SWAP C! ;

( !! Different from ASM: we enable only stream0 !!)
: AUENAIRQ  ( -- )
   AUBAR 0C + DUP W@ 07FFF OR SWAP W! 
   1 01F LSHIFT 1 AUINPCNT @ LSHIFT OR AUBAR 020 + ! ;

: AUCPBUFFN  ( -- )
   AUPCMPART @ AUBUFFLEN * AUPCMADDR @ + ( from )
   AUBUFFNUM @ AUBUFFLEN * AUBUFFADDR + 
   AUBUFFLEN CMOVE ;

: AUCBUFFNUM  ( -- )
   1 AUBUFFNUM +! AUBUFFNUM @ AUBDLENTRYCNT /MOD DROP AUBUFFNUM ! ;

: AUSPWRSTATESUB  ( nid pwrstate -- flag )
   0705 SWAP AUSENDCMD IF 2DROP TRUE ELSE FALSE THEN ;

VARIABLE AUCALLSUB

: AUSPWRSTATE  ( afgnid pwrstate -- flag )
  SWAP OVER 3 = IF 064 DELAY THEN 
 ( pwrstate afgnid )
  OVER 0705 SWAP AUSENDCMD INVERT IF 2DROP FALSE EXIT THEN 
  2DROP DUP 0= IF 0A DELAY THEN 
  TRUE SWAP AUWIDDATA AUAFGSRTWIDID @ DUP AUAFGWIDCNT @ + SWAP 
  DO 
   ( flag pwrstate auwiddata )
    DUP @ 1 0A LSHIFT AND 0<>
    IF
      TRUE AUCALLSUB ! OVER 3 = 
      IF DUP @ 0F 014 LSHIFT AND 014 RSHIFT 4 =
       ( don't power down the widget if it controls EAPD and EAPD_BTLENABLE is set)
        IF DUP AUPINCAPSIDX CELLS + @ 1 010 LSHIFT AND 0<>
          IF I 0F0C 0 AUSENDCMD INVERT 
            IF 2DROP DROP FALSE UNLOOP EXIT THEN 
          ( flag pwrstate auwiddata res resext )
            DROP 2 AND 0<> IF FALSE AUCALLSUB ! THEN 
          THEN
        THEN 
      THEN
      AUCALLSUB @ 
      IF 
        OVER I SWAP AUSPWRSTATESUB INVERT 
        IF 2DROP DROP FALSE UNLOOP EXIT THEN 
      THEN 
    THEN
    AUWIDDATACNT CELLS +
   ( flag pwrstate auwiddata+ )
  LOOP 2DROP ;

: AUGWIDDATAOFFS  ( nid -- offs )
   AUAFGSRTWIDID @ - AUWIDDATACNT CELLS * AUWIDDATA + ;

: AUGWIDTYPE  ( nid -- type )
   AUGWIDDATAOFFS @ 0F 014 LSHIFT AND 014 RSHIFT ;

: AUSPINCTRL  ( nid -- flag )
   DUP AUGWIDTYPE 4 <> IF DROP TRUE EXIT THEN 
   DUP >R 0707 1 6 LSHIFT 1 5 LSHIFT OR 
   R> AUGWIDDATAOFFS AUPINCAPSIDX CELLS + @ 8 AND 0<>
   IF 080 OR THEN AUSENDCMD IF 2DROP TRUE ELSE FALSE THEN ;

: AUGCONNLISTLEN  ( offs -- len )
   AUCONNLISTLENIDX CELLS + @ 07F AND ;

: AUGCONNLISTIDX  ( prevNid nid -- idx TRUE )  ( ... -- FALSE )
   AUGWIDDATAOFFS DUP AUCONNLSTENTCTRLIDX CELLS + @ 
   AUCONNLISTENTRIES ! DUP AUCONNLSTENTCTRL2IDX CELLS + @
   AUCONNLISTENTRIES CELL+ ! 
   AUGCONNLISTLEN AUCONNLISTENTRIES SWAP 0
  ( prevNid addrconnlistentries connlistlen 0 )
   DO 
     2DUP C@ = IF 2DROP I TRUE UNLOOP EXIT THEN 
     1+ 
   LOOP 2DROP FALSE ;

: AUPREPAFG  ( -- flag )
   AUAFGID @ 0300 0F000 AUDEFGAIN OR AUSENDCMD IF 2DROP TRUE ELSE FALSE THEN ;

: AUSEAPD  ( nid -- flag )
   DUP AUGWIDTYPE 4 = 
   IF  
     DUP AUGWIDDATAOFFS AUPINCAPSIDX CELLS + @ 1 010 LSHIFT AND 0<>
     IF 070C 2 AUSENDCMD IF DROP ELSE FALSE EXIT THEN THEN 
   THEN DROP TRUE ;

: AUUNMUTEOUTP  ( nid -- flag )
   DUP AUGWIDDATAOFFS AUWIDCAPSIDX CELLS + @ 6 AND 0<>
   IF DUP AUGWIDTYPE 2 <> 
      IF DUP AUSEAPD INVERT IF DROP FALSE EXIT THEN
        0300 0F000 AUDEFGAIN OR AUSENDCMD IF 2DROP TRUE ELSE FALSE THEN 
      ELSE DROP TRUE 
      THEN
   ELSE DROP TRUE 
   THEN ;

: AUUNMUTEMIXER  ( nid connSelIdx -- flag )
   8 LSHIFT OVER AUGWIDTYPE 2 <> IF 2DROP TRUE EXIT THEN 
   OVER AUGWIDDATAOFFS @ 6 AND 0<>
   IF 0300 SWAP 0F000 OR AUDEFGAIN OR AUSENDCMD IF 2DROP TRUE ELSE FALSE THEN 
   ELSE 2DROP TRUE
   THEN ;

: AUPREPPATH  ( addrOfPath depthOfPath -- flag )
   0 DO
   ( addrOfPath )
     DUP I + C@ DUP AUUNMUTEOUTP INVERT 
     IF 2DROP FALSE CR ." Error: prepare path." UNLOOP EXIT THEN 
   ( addrOfPath nid )
     AUDEFGAIN AUMUTEGAIN ! DUP AUSPINCTRL INVERT 
     IF 2DROP FALSE CR ." Error: set pin ctrl." UNLOOP EXIT THEN 
   ( addrOfPath nid )
     AUGWIDDATAOFFS AUGCONNLISTLEN 1 U>
     IF 2R@ 1- <>
        IF DUP I + DUP 1+ C@ SWAP C@ AUGCONNLISTIDX
     ( addr [idx] flag )
          IF OVER I + C@ OVER AUUNMUTEMIXER INVERT
            IF 2DROP FALSE CR ." Error: unmute mixer." UNLOOP EXIT THEN 
            OVER I + C@ 0701 ROT AUSENDCMD 
            IF 2DROP ELSE DROP FALSE CR ." Error: select connection." UNLOOP EXIT THEN 
          THEN 
        THEN 
     THEN
   LOOP DROP TRUE ;

: AUPREPKNOB  ( -- flag )
   TRUE AUAFGSRTWIDID @ DUP AUAFGWIDCNT @ + SWAP 
   DO 
     I AUGWIDTYPE 6 = 
     IF I 070F 080 AUDEFGAIN OR AUSENDCMD
        IF 2DROP ELSE DROP FALSE CR ." Error: prepare knob." LEAVE THEN 
     THEN 
   LOOP ;

: AUCLBUFF  ( -- )
   AUBUFFADDR AUBUFFLEN AUBDLENTRYCNT * ERASE ; 

: AUCPBUFFALL  ( -- )
   AUPCMADDR @ AUBUFFADDR AUPCMLEN @ CMOVE TRUE AUDATACOPIED ! ;

: AUCPBUFFPART  ( -- )
   AUPCMADDR @ AUBUFFADDR AUBUFFLEN AUBDLENTRYCNT * CMOVE 
   FALSE AUDATACOPIED ! AUBDLENTRYCNT 1- AUPCMPART ! 0 AUBUFFNUM ! ;

: AUCPBUFF  ( -- )
   AUPCMPARTMAX @ AUBDLENTRYCNT U> 
   IF AUCPBUFFPART ELSE AUCPBUFFALL THEN ;

: AUSTOPENGINES  ( -- )
   AUBAR 070 + DUP DUP @ 1 INVERT AND SWAP ! AU64OK @ 
   IF 4 + 0 SWAP ! ELSE DROP THEN ;

: AUSSTREAMOID  ( -- )
   AUBAR AUOUTPBASE @ + DUP @ 0FFFFFF AND 018 010 LSHIFT OR SWAP ! ;

: AUSSTREAMFMT  ( -- )
   AUBAR AUOUTPBASE @ + 012 + DUP W@ 080 AND AUFMT @ OR SWAP W! ;

: AUSCBL  ( -- )
   AUBDLENTRYCNT AUBUFFLEN * AUBAR AUOUTPBASE @ + 8 + ! ;

: AUSLVI  ( -- )
   AUBAR AUOUTPBASE @ + 0C + DUP W@ 0FF00 AND AUBDLENTRYCNT 1- OR SWAP W! ;

: AUSBDL  ( -- )
   AUBAR AUOUTPBASE @ + 018 + AUBDLBUFF OVER ! AU64OK @ 
   IF 4 + 0 SWAP ! ELSE DROP THEN ;

: AUABDLENTRY  ( -- )
   AUBUFFADDR AUBDLBUFF AUBDLENTRYCNT 0 
   DO 
  ( addrBuff addrBDL )
     2DUP ! CELL+ 0 OVER ! CELL+ AUBUFFLEN OVER ! CELL+ 1 OVER ! CELL+ 
     SWAP AUBUFFLEN + SWAP 
   LOOP 2DROP ;

: AUSDPLBASE  ( -- )
   AUBAR 070 + AUDPLBUFF 1 OR OVER ! AU64OK @ 
   IF 4 + 0 SWAP ! ELSE DROP THEN ;

: AUSCONVSTREAMSSUB  ( addrTree depth -- flag )
   DUP 0<>
   IF 1- + C@ AUSCONVSTREAM 
   ELSE 2DROP TRUE 
   THEN ;

: AUSCONVSTREAMS  ( -- flag )
   AUTREEOUTPATH AUTREEOUTDEPTH @ AUSCONVSTREAMSSUB DUP
   IF DROP AUTREEHPPATH AUTREEHPDEPTH @ AUSCONVSTREAMSSUB THEN ;

: AUSRTSTREAM  ( -- )
   AUBAR AUOUTPBASE @ + DUP @ 0CFFE0 AND 010001C OR 2 OR SWAP ! ;

( Finds next space to get the length of a substring)
: AUFNDNSPACE  ( addr -- addrNextSpace )
   BEGIN 1+ DUP C@ 020 = UNTIL ;

( Finds start of subtext in a text-array, subtexts are separated by Spaces)
: AUFNDTXTSRT  ( addr idx -- addrStart )
   DUP 0= IF DROP ELSE 0 DO AUFNDNSPACE 1+ LOOP THEN ;

: AUFRQTXTS  ( -- )
   S" 8.0 11.025 16.0 22.05 32.0 44.1 48.0 88.2 96.0 176.4 192.0 384.0 " ;

: AUFRQTXT  ( idx -- )
   ['] AUFRQTXTS CELL+ CELL+ 1+ SWAP AUFNDTXTSRT DUP AUFNDNSPACE OVER - TYPE SPACE ;

: AUBPSTXTS  ( -- )
   S" 8 16 20 24 32 " ;

: AUBPSTXT  ( idx -- )
   ['] AUBPSTXTS CELL+ CELL+ 1+ SWAP AUFNDTXTSRT DUP AUFNDNSPACE OVER - TYPE SPACE ;

: AUPRFMT  ( rtOfTxts fmt len -- )
  0 DO DUP 1 I LSHIFT AND 0<> IF OVER I SWAP EXECUTE THEN LOOP 2DROP ; 

: AUPRDMAPOS  ( -- )
   CR ." DMA positions" CR 
   AUDPLBUFF AUINPCNT @ 4 + 0 DO DUP @ U. 8 + I 3 = IF CR THEN LOOP DROP ;

( We need to cut the string-array into two, because the length is stored in a byte. Otherwise the length would overflow!)
: AUREGTXTS1  ( -- )
   S" GCAP VMIN VMAJ OUTPAY INPAY GCTL WAKEEN STATESTS GSTS OUTSTRMPAY INSTRMPAY INTCTL INTSTS WALCLK SSYNC CORBLBASE CORBUBASE CORBWP CORBRP CORBCTL CORBSTS CORBSIZE RIRBLBASE RIRBUBASE RIRBWP RINTCNT RIRBCTL RIRBSTS RIRBSIZE ICOI ICII ICIS " ;

: AUREGTXTS2  ( -- )
   S" DPIBLBASE DPIBUBASE SD0CTL SD0STS SD0LPIB SD0CBL SD0LVI SD0FIFOD SD0FMT SD0BDPL SD0BDPU " ;

: AUREGTXT  ( idx -- )
   DUP 020 U< IF ['] AUREGTXTS1 ELSE 020 - ['] AUREGTXTS2 THEN CELL+ CELL+ 1+ SWAP AUFNDTXTSRT DUP AUFNDNSPACE OVER - TYPE ." :" ;

CREATE AUREGOFFS 0 C, 02 C, 03 C, 04 C, 06 C, 08 C, 0C C, 0E C, 010 C, 018 C, 01A C, 020 C, 024 C, 030 C, 038 C, 040 C, 044 C, 
         048 C, 04A C, 04C C, 04D C, 04E C, 050 C, 054 C, 058 C, 05A C, 05C C, 05D C, 05E C, 060 C, 064 C, 068 C, 070 C, 074 C, 0 C, 03 C, 04 C, 08 C, 0C C, 010 C, 012 C, 018 C, 01C C, 

( bytelength of regs [dword:4, word:2, ...])
CREATE AUREGLENS 2 C, 1 C, 1 C, 2 C, 2 C, 4 C, 2 C, 2 C, 2 C, 2 C, 2 C, 4 C, 4 C, 4 C, 4 C, 4 C, 4 C, 2 C, 2 C, 1 C, 1 C, 1 C, 4 C, 4 C, 2 C, 2 C, 1 C, 1 C, 1 C, 4 C, 4 C, 2 C, 4 C, 4 C, 3 C, 1 C, 4 C, 4 C, 2 C, 2 C, 2 C, 4 C, 4 C,

: AUPRREGS  ( -- )
   CR ." Registers" CR 
   02B 0 
   DO 
     I AUREGTXT AUBAR I 021 U> IF AUOUTPBASE @ + THEN AUREGOFFS I + C@ + AUREGLENS I + C@ 
     CASE 
       1 OF >R C@            R> ENDOF 
       2 OF >R W@            R> ENDOF 
       3 OF >R DUP 2+ C@ 010 LSHIFT SWAP W@ OR R> ENDOF 
       4 OF >R @             R> ENDOF 
      ENDCASE 
      U.
   LOOP ;

: AUWIDTXTS  ( -- )
   S" WCaps SuppStrmFmt SuppPCMSize PinCaps ImpApmCaps OutpAmpCaps ConnListLen KnobCaps ConfigDef ConnListEnt ConnListEnt2 " ;

: AUWIDTXT  ( idx -- )
   ['] AUWIDTXTS CELL+ CELL+ 1+ SWAP AUFNDTXTSRT DUP AUFNDNSPACE OVER - TYPE ." :" ;

: AUCPTREE  ( addrTree addrDepth -- )
   AUTREEDEPTH @ DUP 0<> 
   IF DUP ROT ! 0 DO AUTREEPATH I + C@ OVER C! 1+ LOOP DROP 
   ELSE 2DROP DROP 
   THEN ;

: AUCPOUTTREE  ( -- )
   AUTREEOUTPATH AUTREEOUTDEPTH AUCPTREE ; 

: AUCPHPTREE  ( -- )
   AUTREEHPPATH AUTREEHPDEPTH AUCPTREE ; 

: AUCLIDXS  ( -- )
   AUNIDIDXS AUMAXWIDCNT ERASE ;

: AUINCIDX  ( nid -- )
   1 SWAP AUNIDIDXS + C+! ;

: AUINCDEPTH  ( -- )
   1 AUTREEDEPTH +! ;

: AUDECDEPTH  ( -- )
   -1 AUTREEDEPTH +! ;

: AUGVISITED  ( nid -- flag )
   AUNIDIDXS + C@ 0 U> ;

: AUATREE  ( nid -- )
   DUP AUTREEPATH AUTREEDEPTH @ + C! AUINCIDX AUINCDEPTH ;

: AUGNCHILD  ( nid -- nid TRUE )  ( nid -- FALSE )
   DUP AUNIDIDXS + C@ 1- 
  ( nid idx )
   OVER AUGWIDDATAOFFS AUGCONNLISTLEN OVER 
  ( nid idx len idx ) U>
   IF 
    ( nid idx )
     SWAP DUP 1 SWAP AUNIDIDXS + C+!
    ( idx nid )
     AUGWIDDATAOFFS DUP AUCONNLSTENTCTRLIDX CELLS + @ 
     AUCONNLISTENTRIES ! AUCONNLSTENTCTRL2IDX CELLS + @
     AUCONNLISTENTRIES CELL+ ! 
    ( idx )
     AUCONNLISTENTRIES + C@ TRUE 
   ELSE 2DROP FALSE 
   THEN ;

: AUGPARENT  ( -- nid TRUE )  ( -- FALSE )
   AUDECDEPTH AUTREEDEPTH @ DUP 0= IF DROP FALSE ELSE AUTREEPATH + C@ TRUE THEN ;

VARIABLE THEEND

( Output: AUTREEPATH and AUTREEDEPTH. AUTREEDEPTH is non-zero, if DAC was found)
: AUPARSE  ( nidJack -- )
   FALSE THEEND ! 0 AUTREEDEPTH ! AUCLIDXS DUP AUATREE
   AUGNCHILD 
  ( [nid] flag )
   BEGIN 
     IF DUP AUGVISITED 
       IF 
         DROP AUGPARENT IF AUGNCHILD ELSE TRUE THEEND ! THEN
       ELSE DUP AUATREE DUP AUGWIDTYPE 0= IF ( DAC) DROP TRUE THEEND ! ELSE AUGNCHILD THEN 
       THEN 
     ELSE AUGPARENT IF AUGNCHILD ELSE TRUE THEEND ! THEN
     THEN 
   THEEND @ UNTIL ;

( uses AUTREEPATH and AUTREEDEPTH, we will copy from them)
: AUPARSEOUTJACK  ( jacktype -- )
   0 AUTREEDEPTH ! 
   AUAFGSRTWIDID @ DUP AUAFGWIDCNT @ + SWAP
   DO  
  ( flag jacktype )
     I AUGWIDTYPE 4 = 
    ( Pin?)
     IF I AUGWIDDATAOFFS 3 CELLS + @ 010 AND 0<> 
      ( OutpCap?)
       IF 
         I AUGWIDDATAOFFS 8 CELLS + @ 3 01E LSHIFT AND 01E RSHIFT 1 <> 
   ( PortConn is None?)
         IF DUP 0 >= 
          ( JacktypeIsNotNegative?)
           IF 
             I AUGWIDDATAOFFS 8 CELLS + @ 0F 014 LSHIFT AND 014 RSHIFT OVER =            
             ( JackType==DeviceType?)
             IF I AUGWIDDATAOFFS @ 1 9 LSHIFT AND 0=
               ( NotDigital?)
               IF I AUPARSE AUTREEDEPTH @ 0<> IF LEAVE THEN THEN  
             THEN  
           THEN 
         THEN 
       THEN
     THEN 
   LOOP DROP ;

: AUPARSEOUT  ( -- ) 
   0 AUTREEOUTDEPTH ! 0 AUTREEHPDEPTH ! 
  ( LineOut)
   0 AUPARSEOUTJACK AUCPOUTTREE AUTREEOUTDEPTH @ 0= 
    ( Speaker)
     IF 1 AUPARSEOUTJACK AUCPOUTTREE THEN 
  ( HP) 
   2 AUPARSEOUTJACK AUCPHPTREE  
   AUTREEOUTDEPTH @ 0= AUTREEHPDEPTH @ 0= AND 
  ( None found: choose first output pin)
   IF -1 AUPARSEOUTJACK AUCPOUTTREE THEN ;

: AUPRTREE  ( addrTree depth -- )
   CR 0 DO DUP C@ . 1+ LOOP DROP ;

( **********Public words and IRQ-handler**********)

: AUINIT  ( -- flag )
   AURESET INVERT IF FALSE EXIT THEN 
   AUSA64OK AUOUTP INVERT IF FALSE EXIT THEN
   AUGINPCNT 
   04E AURBSI INVERT IF FALSE EXIT THEN 
   04E AUGRBSI AUCORBSI ! 
   AURESCORBRP INVERT IF FALSE EXIT THEN 
   AUCLCORBWP AUCORBBUFF 040 AUSBUFF AUDISCMEIE 
   05E AURBSI INVERT IF FALSE EXIT THEN 
   05E AUGRBSI AURIRBSI ! 
   AUCLRIRBWP AURIRBBUFF 050 AUSBUFF
   AUDISRIRBIRQ AUDISIRQ AUCLSTATUS 
   04C AUSRTRB 05C AUSRTRB 
   AURESSTREAM INVERT IF FALSE EXIT THEN 
   0 AUMUTEGAIN !
   AUGCODECSDATA INVERT IF FALSE CR ." Error: get codecs data." EXIT THEN 
   AUGAFGSUPPSTREAMFMT INVERT IF FALSE EXIT THEN 
   AUGAFGSUPPFMT INVERT IF FALSE EXIT THEN 
   TRUE DUP AUINITED ! ;

: AUGETSUPPFMT  ( -- formatPCM formatStream )
   AUGSUPPPCMFMT AUGSUPPSTREAMFMT ;

: AUPRINTFMT  ( formatPCM formatStream -- )
   CR ." Supported stream formats: "
   DUP 1 AND 0<> IF ." pcm " THEN 
   DUP 2 AND 0<> IF ." float32 " THEN 
   DUP 4 AND 0<> IF ." ac3 " THEN 
   7 AND 0= IF ." none " THEN 
   CR ." Supported SampleRate: "
   DUP ['] AUFRQTXT SWAP 0C AUPRFMT
   CR ." Supported BPS: "
   010 RSHIFT ['] AUBPSTXT SWAP 5 AUPRFMT ;

: AUINFO  ( -- )    ( for debugging)
   AUINITED @ IF AUPRDMAPOS AUPRREGS THEN ;

: AUCODECSINFO  ( -- )    ( for debugging)
( HEX !? )
   AUINITED @ INVERT IF FALSE EXIT THEN 
   CR ." Codecs-mask:" AUCODECSMASK @ U.
   CR ." Root-node"
   CR ." VenId DevId: " AUCODECDEVID @ U. 
   CR ." RevId: " AUCODECREVID @ U.
   CR ." FG-num: " AUCODECFGNUM @ U.
   CR ." AFG-node found (id): " AUAFGID @ U.  ( shl edx, 8 !?)
   CR ." AFG-node wigdets: " AUAFGSRTWIDID @ U. AUAFGWIDCNT @ U.
   AUAFGSRTWIDID @ DUP AUAFGWIDCNT @ + SWAP
   DO
     CR I . CR I AUGWIDDATAOFFS AUWIDDATACNT 0
     DO 
       I AUWIDTXT DUP I CELLS + @ U.
     LOOP DROP CR ." Press a key" KEY?
   LOOP ;

: AUPLAY  ( addrPCM len fmt -- flag )
   AUINITED @ INVERT IF FALSE EXIT THEN 
   AUFMT ! AUPCMLEN ! AUPCMADDR !
   AUPCMLEN @ AUBUFFLEN /MOD SWAP 0> 
   IF 1+ THEN AUPCMPARTMAX ! 1 AUPCMPARTMAX +!
   AUCLBUFF AUCPBUFF AUSTOPENGINES AURESSTREAM INVERT 
   IF FALSE EXIT THEN
   AUSSTREAMOID AUSSTREAMFMT AUSCBL AUSLVI AUSBDL AUABDLENTRY
   AUSDPLBASE AUAFGID @ 0 AUSPWRSTATE INVERT 
   IF FALSE CR ." Error: set power state." EXIT THEN 

( CR ." Before AUPARSEOUT .S=" .S )
   AUPARSEOUT 
( CR ." After AUPARSEOUT .S=" .S )
( CR ." AUTREEOUTDEPTH=" AUTREEOUTDEPTH ? )
( AUTREEOUTDEPTH @ 0<> IF AUTREEOUTPATH AUTREEOUTDEPTH @ AUPRTREE THEN )
( CR ." AUTREEHPDEPTH=" AUTREEHPDEPTH ? )
( AUTREEHPDEPTH @ 0<> IF AUTREEHPPATH AUTREEHPDEPTH @ AUPRTREE THEN )
( CR ." Press a key" KEY? )

 ( In case of problems with Parsing,)
 ( we can use the HDAudio-specification and AUGCODECSDATA to have a tree,)
 ( as I did below.)
 ( Widgets below work with my ASUS EeePC)
 ( Comment out the words related to Parsing above)
( 014 AUTREEOUTPATH C! )
( 0C AUTREEOUTPATH 1+ C! )
( 02 AUTREEOUTPATH 2+ C! )
( 3 AUTREEOUTDEPTH ! )

( 01A AUTREEHPPATH C! )
( 0C AUTREEHPPATH 1+ C! )
( 02 AUTREEHPPATH 2+ C! )
( 3 AUTREEHPDEPTH ! )

   AUPREPAFG INVERT IF FALSE CR ." Error: prepare AFG" EXIT THEN 
   AUTREEOUTPATH AUTREEOUTDEPTH @ AUPREPPATH INVERT 
   IF FALSE CR ." Error: prepare path" EXIT THEN 
   AUTREEHPPATH AUTREEHPDEPTH @ AUPREPPATH INVERT 
   IF FALSE CR ." Error: prepare path" EXIT THEN 
   AUPREPKNOB INVERT 
   IF FALSE CR ." Error: prepare knob" EXIT THEN 
   AUSCONVSTREAMS INVERT 
   IF FALSE CR ." Error: set converter stream" EXIT THEN 
   AUENAIRQ AUSRTSTREAM TRUE ;

: AUWAV  ( addrOfWavFile -- flag )
   -1 AUPLAYFMT ! -1 AUPLAYRATE ! AUGETSUPPFMT NIP 1 AND 0= 
   IF DROP FALSE CR ." Audio: unsupported format (PCM not supp.)" EXIT THEN
   DUP 014 + W@ 1 <> 
   IF DROP FALSE CR ." Audio: unsupported format (not PCM)" EXIT THEN 
   AUGETSUPPFMT DROP OVER 022 + W@  
( check BPS)
  ( addrWav pcmfmt filefmt )
   CASE 
     020 OF >R DUP 1 014 LSHIFT AND 0<> IF 4 4 LSHIFT AUPLAYFMT ! THEN R> ENDOF 
     018 OF >R DUP 1 013 LSHIFT AND 0<> IF 3 4 LSHIFT AUPLAYFMT ! THEN R> ENDOF 
     014 OF >R DUP 1 012 LSHIFT AND 0<> IF 2 4 LSHIFT AUPLAYFMT ! THEN R> ENDOF 
     010 OF >R DUP 1 011 LSHIFT AND 0<> IF 1 4 LSHIFT AUPLAYFMT ! THEN R> ENDOF 
      08 OF >R DUP 1 010 LSHIFT AND 0<> IF          0 AUPLAYFMT ! THEN R> ENDOF 
   ENDCASE 
   AUPLAYFMT @ -1 = 
   IF 2DROP FALSE CR ." Audio: unsupported format" EXIT THEN 
( check rate)
   OVER 018 + @  
  ( addrWav pcmfmt filefmt )
   CASE 
( 192000)
     02EE00 OF >R DUP 1 0A LSHIFT AND 0<> IF 3 0B LSHIFT AUPLAYRATE ! THEN R> ENDOF 
( 176400)
     02B110 OF >R DUP 1 9 LSHIFT AND 0<> IF 1 0E LSHIFT 3 0B LSHIFT OR AUPLAYRATE ! THEN R> ENDOF 
( 96000)
     017700 OF >R DUP 1 8 LSHIFT AND 0<> IF 1 0B LSHIFT AUPLAYRATE ! THEN R> ENDOF 
( 88200)
     015888 OF >R DUP 1 7 LSHIFT AND 0<> IF 1 0E LSHIFT 1 0B LSHIFT OR AUPLAYRATE ! THEN R> ENDOF 
( 48000)
      0BB80 OF >R DUP 1 6 LSHIFT AND 0<> IF 0 AUPLAYRATE ! THEN R> ENDOF 
( 44100)
      0AC44 OF >R DUP 1 5 LSHIFT AND 0<> IF 1 0E LSHIFT AUPLAYRATE ! THEN R> ENDOF 
( 32000)
      07D00 OF >R DUP 1 4 LSHIFT AND 0<> IF 1 0B LSHIFT 2 8 LSHIFT OR AUPLAYRATE ! THEN R> ENDOF 
( 22050)
      05622 OF >R DUP 1 3 LSHIFT AND 0<> IF 1 0E LSHIFT 1 8 LSHIFT OR AUPLAYRATE ! THEN R> ENDOF 
( 16000)
      03E80 OF >R DUP 1 2 LSHIFT AND 0<> IF 3 8 LSHIFT AUPLAYRATE ! THEN R> ENDOF 
( 11025)
      02B11 OF >R DUP 1 1 LSHIFT AND 0<> IF 1 0E LSHIFT 3 8 LSHIFT OR AUPLAYRATE ! THEN R> ENDOF 
( 8000)
      01F40 OF >R DUP 1 AND 0<> IF 5 8 LSHIFT AUPLAYRATE ! THEN R> ENDOF 
   ENDCASE 
   AUPLAYRATE @ -1 = 
   IF 2DROP FALSE CR ." Audio: unsupported rate" EXIT THEN 
   DROP AUPLAYRATE @ AUPLAYFMT @ OR AUPLAYFMT !
  ( addofwav )
( SetChNum)
   DUP 016 + W@ 1- AUPLAYFMT @ OR AUPLAYFMT ! 
( Advance memaddr to the beginning of possible pcm-data)
   024 + DUP @ 061746164 <> 
   IF 
     BEGIN 4 + DUP @ + 4 + DUP @ 061746164 = UNTIL 
   THEN
  ( addofwav+ )
( GetData)
   4 + DUP @ ( addrofwav+ length )
   >R 4 + R> AUPLAYFMT @ AUPLAY ;

: AUSTOP  ( -- )
   AUINITED @ IF AUDISIRQ AUCLSTREAM THEN ;

: AUPAUSE  ( -- )
   AUINITED @ 
   IF TRUE AUPAUSED ! AUBAR AUOUTPBASE @ + DUP @ 0FFFFFD AND SWAP !
   AUDISIRQ THEN ;

: AURESUME  ( -- )
   AUINITED @ AUPAUSED @ AND IF FALSE AUPAUSED ! 
   AUENAIRQ AUBAR AUOUTPBASE @ + DUP @ 2 OR SWAP ! THEN ;

: AUSETVOL  ( muteandgain -- flag )
   AUINITED @ INVERT IF DROP EXIT THEN 
   1 7 LSHIFT 07F OR AND AUMUTEGAIN !
   TRUE AUTREEOUTDEPTH @ 0 
   DO 
     AUTREEOUTPATH I + C@ AUGWIDDATAOFFS @ 6 AND 0<>
     IF 
       AUTREEOUTPATH I + C@ 0300 0F000 AUMUTEGAIN @ OR AUSENDCMD  
       IF 2DROP ELSE DROP FALSE CR ." Error: set volume" LEAVE THEN 
     THEN 
   LOOP ;

: AUGETVOL  ( -- muteandgain )
   AUMUTEGAIN @ ;

( irq-handler)
: AUISR  ( -- )
( CR ." ***AUISR***")
   AUINITED @ INVERT IF EXIT THEN 
   AUBAR AUOUTPBASE @ + 3 + C@ 4 AND 0<>
   IF AUBAR 024 + @ 1 AUINPCNT @ LSHIFT AND 0<>
     IF AUDATACOPIED @ INVERT
       IF 1 AUPCMPART +! AUPCMPART @ AUPCMPARTMAX @ U> 
         IF AUSTOP ELSE AUCPBUFFN AUCBUFFNUM THEN 
       ELSE -1 AUPCMPARTMAX +! AUPCMPARTMAX @ 0= IF AUSTOP THEN 
       THEN
     THEN 
   THEN 
   AUCLIRQ ;

: AUIRQON  ( -- )
   ['] AUISR AUSETISR ;

: AUIRQOFF  ( -- )
   0 AUSETISR ;


